# Quest 6.7 RotateVowels

## Название файла Go
`rotatevowels/main.go`

---

## Условия задания 

| **Instruction** | **Перевод** |
|---------------------------|--------------|
| Program checks arguments for vowels. | Программа проверяет аргументы на наличие гласных. |
| *If vowels exist, mirror their positions. (`y` is not a vowel)* | *Если есть гласные, поменять их местами («отразить»). `y` не считается гласной* |
| *If no arguments, print a new line ("`\n`")* | *Если аргументов нет — вывести перенос строки ("`\n`")* |
| *If no vowels, print arguments as-is* | *Если гласных нет — вывести аргументы без изменений* |

---

Нужно написать функцию, которая **обрабатывает все аргументы командной строки**, объединяет их в одну строку и «зеркально» меняет местами все **гласные буквы** (`a`, `e`, `i`, `o`, `u` — без `y`).
Если аргументов нет — программа должна просто вывести пустую строку.

---

## Примеры

**Пример 1**  
- **Ввод:** `$ go run . "Hello World"`  
- **Вывод:** `Hollo Werld`

**Пример 2**  
- **Ввод:** `$ go run . "HEllO World" "problem solved"`  
- **Вывод:** `Hello Werld problom sOlvEd`

**Пример 3**  
- **Ввод:** `$ go run . "str" "shh" "psst"`  
- **Вывод:** `str shh psst`

**Пример 4**  
- **Ввод:** `$ go run . "happy thoughts" "good luck"`  
- **Вывод:** `huppy thooghts guod lack`

**Пример 5**  
- **Ввод:** `$ go run . "aEi" "Ou"`  
- **Вывод:** `uOi Ea`

**Пример 6**  
- **Ввод:** `$ go run .`  
- **Вывод:** *(new line)*

---

## Решение

```go
package main

import (
	"os"

	"github.com/01-edu/z01"
)

func main() {
	args := os.Args

	// Если нет аргументов — просто выводим новую строку
	if len(args) < 2 {
		z01.PrintRune('\n')
		return
	}

	// Объединяем все аргументы в одну строку через пробел
	str := ""
	for i := 1; i < len(args); i++ {
		if i > 1 {
			str += " "
		}
		str += args[i]
	}

	runes := []rune(str)

	// Находим индексы всех гласных букв
	vowelIndexes := []int{}
	for i, r := range runes {
		if isVowel(r) {
			vowelIndexes = append(vowelIndexes, i)
		}
	}

	// "Отзеркаливаем" гласные — меняем их местами с концов к центру
	for i := 0; i < len(vowelIndexes)/2; i++ {
		j := len(vowelIndexes) - 1 - i
		runes[vowelIndexes[i]], runes[vowelIndexes[j]] = runes[vowelIndexes[j]], runes[vowelIndexes[i]]
	}

	// Выводим итоговую строку
	for _, r := range runes {
		z01.PrintRune(r)
	}
	z01.PrintRune('\n')
}

// isVowel — проверяет, является ли символ гласной буквой
func isVowel(r rune) bool {
	vowels := "aeiouAEIOU"
	for _, v := range vowels {
		if r == v {
			return true
		}
	}
	return false
}
```

---

## Ключевые понятия

| **Инструмент / элемент кода** | **Объяснение и назначение** |
|-------------------------------|------------------------------|
| **Пакет (`package main`)** | Определяет, что это исполняемая программа (а не библиотека). |
| **Импорт (`import ...`)** | Подключает нужные пакеты (`os` для аргументов, `z01` для вывода). |
| **`os.Args`** | Массив аргументов, переданных в программу через командную строку. |
| **Срез (`[]rune`)** | Позволяет работать с каждым символом строки, включая Unicode. |
| **Цикл `for`** | Проходит по всем символам строки или индексам гласных. |
| **Функция `isVowel()`** | Проверяет, является ли символ гласной. |
| **`z01.PrintRune()`** | Выводит символ в стандартный вывод (по одному за раз). |
| **Срез индексов (`vowelIndexes`)** | Хранит позиции гласных для их обмена. |

---

## Логика и пошаговый разбор кода

### 1. Проверка аргументов
```go
if len(args) < 2 {
	z01.PrintRune('\n')
	return
}
```

- Проверяем, передал ли пользователь хотя бы один аргумент (кроме имени программы).
- Если аргументов нет, выводим новую строку (`\n`) и завершаем программу.
- Это соответствует требованию задания: если аргументов нет — просто новая строка.

---

### 2. Объединение всех аргументов
```go
str := ""
for i := 1; i < len(args); i++ {
	if i > 1 {
		str += " "
	}
	str += args[i]
}
```

- Проходим по всем аргументам `args[1:]` (пропуская имя программы `args[0]`).
- Добавляем пробел перед каждым аргументом, кроме первого.
- В результате получаем **единую строку**, которая объединяет все аргументы.

**Пример:**  
Ввод: `go run . "Hello" "World"` → `str = "Hello World"`

---

### 3. Преобразование строки в срез рун
```go
runes := []rune(str)
```

- Преобразуем строку в срез `runes`, чтобы можно было изменять отдельные символы.
- В Go строки неизменяемы, поэтому для обмена символов нужно работать с `[]rune`.

---

### 4. Поиск индексов гласных
```go
vowelIndexes := []int{}
for i, r := range runes {
	if isVowel(r) {
		vowelIndexes = append(vowelIndexes, i)
	}
}
```

- Проходим по каждому символу (руне) строки.
- Если символ — гласная, добавляем её индекс в `vowelIndexes`.

**Пример:**  
Ввод: `"Hello World"` → `vowelIndexes = [1, 4, 7]`
- `H e l l o W o r l d`
- Гласные: `e` (индекс 1), `o` (индекс 4), `o` (индекс 7)

---

### 5. Отзеркаливание гласных
```go
for i := 0; i < len(vowelIndexes)/2; i++ {
	j := len(vowelIndexes) - 1 - i
	runes[vowelIndexes[i]], runes[vowelIndexes[j]] = runes[vowelIndexes[j]], runes[vowelIndexes[i]]
}
```

- Меняем местами первую и последнюю гласную, вторую и предпоследнюю и так далее.
- Используем формулу: `j = len(vowelIndexes) - 1 - i` для зеркального индекса.

**Пример:**  
`vowelIndexes = [1, 4, 7]`
- Меняем: `runes[1]` ↔ `runes[7]` → `e` ↔ `o`
- `runes[4]` остаётся на месте (центральная гласная, если нечётное число)

Результат для `"Hello World"` → `"Hollo Werld"`

---

### 6. Вывод результата
```go
for _, r := range runes {
	z01.PrintRune(r)
}
z01.PrintRune('\n')
```

- Проходим по всем рунам и печатаем их по одному с помощью `z01.PrintRune`.
- После цикла выводим перенос строки, чтобы завершить вывод корректно.

---

### 7. Функция проверки гласной
```go
func isVowel(r rune) bool {
	vowels := "aeiouAEIOU"
	for _, v := range vowels {
		if r == v {
			return true
		}
	}
	return false
}
```

- Проверяет, является ли символ гласной (a, e, i, o, u, A, E, I, O, U).
- `y` не учитывается по условиям задания.
- Возвращает `true`, если символ гласная, иначе `false`.

**Пример:**
- `isVowel('a')` → `true`
- `isVowel('y')` → `false`

---

## Визуализация кода
Ввод: `"happy" "thoughts"`
1. Объединяем аргументы → `"happy thoughts"`
2. Срез рун: `[h a p p y [ ] t h o u g h t s]` (`[ ]` - пробел)
3. Индексы гласных: `[1, 8, 9]` (`y` не считаем)
  - `runes[1] = a`
  - `runes[8] = o`
  - `runes[9] = u`
4. Обмен:
  - `runes[1]` ↔ `runes[9]` → `a` ↔ `u`
  - `runes[8]` ↔ `runes[8]` → остаётся `o`
5. Результат: `[h u p p y [ ] t h o a g h t s]`

---

## Глоссарий

| **Термин** | **Понятное объяснение** |
|-------------|--------------------------|
| **Аргументы программы** | Всё, что мы вводим после `go run .` в терминале. |
| **Руна (`rune`)** | Символ Unicode (одна буква, включая пробелы и спецсимволы). |
| **Срез (`slice`)** | Гибкий массив, где можно добавлять элементы (`append`). |
| **ASCII порядок** | Последовательность символов в стандартной кодировке. |
| **Функция** | Независимый блок кода, выполняющий одно действие. |
| **Индекс** | Позиция символа в строке (начиная с 0). |
| **Отражение (mirror)** | Меняем порядок элементов на противоположный. |

---

## Заключение

В этом задании важно понять:
- как работать с аргументами командной строки (`os.Args`);
- как проверять и хранить символы в срезах (`[]rune`);
- как выделять и обрабатывать только определённые символы (в данном случае — гласные);
- и как “зеркально” переставлять элементы массива.  
Это упражнение тренирует **работу со строками, циклами и условиями** — базовые, но ключевые навыки в Go.
