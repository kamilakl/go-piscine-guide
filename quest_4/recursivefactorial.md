# Quest 4.2 Recursive Factorial

## Название файла Go
`recursivefactorial.go`

---

## Условия задания

| **Instruction** | **Перевод** |
|---------------------------|--------------|
| *Write a recursive function that returns the factorial of the `int` passed as parameter. Errors (non possible values or overflows) will return `0`. `for` is forbidden for this exercise.* | Напишите рекурсивную функцию, возвращающую факториал целого числа, переданного в качестве параметра. В случае ошибок (недопустимые значения или переполнение) возвращается `0`. Использование цикла `for` запрещено.* |

---

Нужно написать рекурсивную функцию, которая вычисляет факториал числа.  
Функция должна учитывать отрицательные значения и переполнение.

### Пример выполнения

| Вход | Ход выполнения | Результат |
|------|----------------|------------|
| 0 | 0! = 1 | 1 |
| 1 | 1! = 1 | 1 |
| 3 | 3 × 2 × 1 | 6 |
| 5 | 5 × 4 × 3 × 2 × 1 | 120 |
| -3 | Ошибка, отрицательное число | 0 |
| 25 | Переполнение, ограничено | 0 |

---

## Решение

```go
package piscine

func RecursiveFactorial(nb int) int {
	if nb == 1 || nb == 0 {
		return 1
	} else if nb < 0 || nb > 20 {
		return 0
	}
	if nb > 1 {
		return nb * RecursiveFactorial(nb-1)
	}
	return 0
}
```

---

## Ключевые понятия

| **Термин или инструмент** | **Объяснение** |
|----------------------------|----------------|
| **Факториал (Factorial)** | Произведение всех чисел от 1 до `n`: <br> `n! = 1 × 2 × 3 × ... × n`. |
| **Рекурсия (Recursion)** | Метод, когда функция вызывает саму себя до тех пор, пока не достигнет **базового случая**. |
| **Базовый случай (Base Case)** | Условие, при котором рекурсия прекращается. Для факториала: `0! = 1` и `1! = 1`. |
| **Переполнение (Overflow)** | Когда результат вычислений выходит за пределы типа `int`. Здесь ограничено `nb > 20`. |
| **Условный оператор `if`** | Позволяет проверять разные условия: отрицательные числа, базовые случаи, переполнение и т.д. |
| **Стек вызовов (Call Stack)** | Это структура данных, где программа хранит информацию обо всех активных функциях. <br> Когда функция вызывается, в стек помещается её “фрейм” (данные вызова). Когда функция завершается, её фрейм удаляется со стека. |
| **Фрейм вызова (Stack Frame)** | Это блок памяти, в котором хранятся параметры функции, её локальные переменные и адрес возврата (куда вернуться после завершения). <br>При каждом рекурсивном вызове создаётся новый фрейм, который кладётся **на вершину стека**. Когда функция достигает базового случая, начинается “раскрутка”: фреймы удаляются в обратном порядке, и возвращаются результаты. |
---

### Как работает стек вызовов при рекурсии

Когда программа вызывает функцию, она **сохраняет информацию о текущем месте выполнения** и переходит внутрь функции.  
Эта информация (параметры функции, локальные переменные, адрес возврата) помещается в **стек вызовов (call stack)**.

Рассмотрим пример: `RecursiveFactorial(4)`

1. Главная программа вызывает `RecursiveFactorial(4)`. В стек помещается первый **фрейм** — данные этого вызова (`nb = 4`).
2. Функция вызывает `RecursiveFactorial(3)` → создаётся новый фрейм, второй уровень стека.
3. Затем `RecursiveFactorial(2)` → ещё один фрейм.
4. Потом `RecursiveFactorial(1)` → базовый случай → возвращаем **1**.

Теперь начинается **раскрутка стека** (возврат результатов назад):

- Вызов с `nb = 1` завершился, его фрейм удаляется, результат = **1**.  
- Вызов с `nb = 2` получает результат от предыдущего вызова и вычисляет:  
  `2 × 1 = 2` → возвращает 2 → фрейм удаляется.  
- Вызов с `nb = 3` получает результат 2 и вычисляет:  
  `3 × 2 = 6` → возвращает 6 → фрейм удаляется.  
- Вызов с `nb = 4` получает результат 6 и вычисляет:  
  `4 × 6 = 24` → возвращает 24 → фрейм удаляется.

Когда стек опустошается рекурсия завершается, и главный вызов получает итоговый результат: **4! = 24**.

---

## Логика и пошаговый разбор кода

### 1. Объявление функции

```go
func RecursiveFactorial(nb int) int {
```

Функция принимает одно целое число `nb` и возвращает его факториал типа данных `int`.

---

### 2. Проверка базовых случаев и ограничений

```go
if nb == 1 || nb == 0 {
	return 1
} else if nb < 0 || nb > 20 {
	return 0
}
```

- `nb == 0 || nb == 1` → **базовый случай** (остановка рекурсии).  
- `nb < 0` → факториал отрицательных чисел не существует.  
- `nb > 20` → защита от переполнения (`20! > 2.4e18`, что выходит за диапазон `int64`).

---

### 3. Рекурсивный вызов

```go
if nb > 1 {
	return nb * RecursiveFactorial(nb-1)
}
```

Каждый вызов уменьшает аргумент `nb` на 1, пока не достигнет базового случая.  
На каждом уровне функции происходит умножение текущего числа на результат предыдущего вызова.

---
### 4. Возврат результата

```go
return 0
```

Финальный `return 0` добавлен как защита — если число не попадает ни под одно условие (например, при некорректном вводе).

---
## Визуализация рекурсии

```
RecursiveFactorial(4)
│
├── 4 * RecursiveFactorial(3)
│     ├── 3 * RecursiveFactorial(2)
│     │     ├── 2 * RecursiveFactorial(1)
│     │     │     └── 1 (базовый случай)
│     │     └── 2 * 1 = 2
│     └── 3 * 2 = 6
└── 4 * 6 = 24
```

---
## Заключение

- Рекурсия позволяет выразить факториал **в виде простой математической формулы**.  
- Нужно обязательно указывать **базовые случаи**, иначе рекурсия станет бесконечной.  
- Для защиты от ошибок добавлены условия на **отрицательные значения** и **переполнение**.  