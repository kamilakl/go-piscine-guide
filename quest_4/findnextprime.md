# Quest 4.8 Find Next Prime

## Название файла Go
`findnextprime.go`

---

## Условия задания

| **Instruction** | **Перевод** |
|---------------------------|--------------|
| *Write a function that returns the first prime number that is equal or superior to the `int` passed as parameter. The function must be optimized in order to avoid time-outs with the tester. (We consider that only positive numbers can be prime numbers).* | *Напишите функцию, которая возвращает первое простое число, **равное или большее**, чем переданное в качестве параметра. Функция должна быть оптимизирована, чтобы избежать тайм-аута. (Считаем, что только положительные числа могут быть простыми).* |

---

## Что нужно сделать

Нужно найти ближайшее простое число, которое:
- либо равно данному `nb`,
- либо больше него, если само `nb` не является простым.

---

### Примеры

| Входное значение | Проверка | Результат |
|------------------|-----------|------------|
| 5 | 5 уже простое | 5 |
| 4 | следующее простое — 5 | 5 |
| 14 | следующее простое — 17 | 17 |
| 1 | ближайшее простое — 2 | 2 |
| 20 | следующее простое — 23 | 23 |

---

## Решение

```go
package piscine

func FindNextPrime(nb int) int {
	if nb < 2 {
		return 2
	}
	for {
		if IsPrime(nb) {
			return nb
		}
		nb++
	}
}
```

---

### Примечание о `IsPrime`

Функция **`IsPrime`** у нас уже реализована в предыдущем задании (`isprime.go`)  
и находится в той же директории / пакете `piscine`.

Поэтому импортировать её не нужно: Go видит функции, объявленные в том же пакете.

Главное условие:
- В обоих файлах (`isprime.go` и `findnextprime.go`) должно быть указано одинаковое объявление пакета:

```go
package piscine
```

Если все находится в одной папке и пакете,  вызов `IsPrime(nb)` будет работать сразу без дополнительных импортов.

---
## Ключевые понятия

| **Термин или инструмент** | **Объяснение** |
|----------------------------|----------------|
| **Простое число (Prime number)** | Число больше 1, которое делится только на 1 и на само себя. Примеры: 2, 3, 5, 7, 11. |
| **Функция `IsPrime`** | Проверяет является ли число простым. Возвращает `true` или `false`. |
| **Цикл `for {}` (бесконечный)** | Выполняется до тех пор, пока внутри не сработает `return`. <br> Это нормальный способ поиска пока определенное условие не выполнится (в нашем случае пока `IsPrime` не станет `true`). <br> У цикла `for` в Go есть разные формы. Подробнее: [Metanit](https://metanit.com/go/tutorial/2.10.php)|
| **Оператор `%` (остаток от деления)** | Проверяет, делится ли число нацело. Если `nb % i == 0`, значит `i` — делитель `nb`. |

---

## Логика работы

Проверяем, меньше ли 2-х у нас `nb` ч
Если да то сразу возвращаем 2, так как это самое первое простое число.

Если `nb` ≥ 2, запускаем бесконечный цикл:
- Проверяем простое ли текущее число с помощью `IsPrime(nb)`  
- Если да то возвращаем его  
- Если нет — увеличиваем `nb` на 1 и продолжаем.

Бесконечный цикл остановится при выполнении условия (нашли prime number, значение функции Isprime - `true`)

---

## Пример выполнения

Пусть `nb = 14`.

| Шаг | Значение `nb` | Проверка `IsPrime(nb)` | Результат |
|------|----------------|--------------------------|------------|
| 1 | 14 | false (делится на 2 и 7) | увеличиваем до 15 |
| 2 | 15 | false (делится на 3 и 5) | увеличиваем до 16 |
| 3 | 16 | false (делится на 2) | увеличиваем до 17 |
| 4 | 17 | true | возвращаем 17 |

**Результат:** 17

---

## Заключение

В этом задании мы используем уже существующую функцию `IsPrime` чтобы построить более сложную. 
Это пример того как функции можно вызывать внутри других функций вместо переписывания одного и того же заново. 
Такой подход позволяет повторно использовать одну и ту же логику в разных местах программы и делает код короче, понятнее и легче для отладки.

Да, все решение можно было бы написать внутри одной большой функции, но чем объемнее задача, тем менее читабельным и удобным для поддержки будет становиться код.
Важно чтобы код был получается читаемым, переиспользуемым и устойчивым к ошибкам.