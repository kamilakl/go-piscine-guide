# Quest 4.5 Recursive Fibonacci

## Название файла Go
`fibonacci.go`

---

## Условия задания

| **Instruction** | **Перевод** |
|---------------------------|--------------|
| *Write a recursive function that returns the value at the position `index` in the Fibonacci sequence. The first value is at index 0. The sequence starts this way: 0, 1, 1, 2, 3 etc... A negative index will return `-1`. `for` is forbidden for this exercise.* | *Напишите **рекурсивную функцию**, которая возвращает число Фибоначчи на позиции `index`. Первое значение находится по индексу 0. Последовательность начинается так: 0, 1, 1, 2, 3 ... Для отрицательных индексов возвращайте `-1`. Использовать цикл `for` запрещено.* |

---

Нужно написать рекурсивную функцию, которая возвращает элемент последовательности Фибоначчи по индексу.

### Пример

- **Ввод:** `index == 6`  
- **Вывод:** `8`

---

## Решение
```go
package piscine

func RecursiveFibonacci(index int) int {
	if index < 0 {
		return -1
	}
	if index == 0 {
		return 0
	}
	if index == 1 {
		return 1
	}
	return RecursiveFibonacci(index-1) + RecursiveFibonacci(index-2)
}
```

---

## Ключевые понятия

| **Термин или инструмент** | **Объяснение** |
|----------------------------|----------------|
| Последовательность Фибоначчи | Числа, где каждое последующее — это сумма двух предыдущих: 0, 1, 1, 2, 3, 5, 8... |
| Рекурсия | Процесс, когда функция вызывает сама себя, пока не достигнет базового случая. |
| Базовый случай (base case) | Условие, при котором рекурсия прекращается. В этом задании: `index == 0` или `index == 1`. |
| Возврат значения (`return`) | Завершает выполнение функции и возвращает вычисленное значение. |
| Отрицательный индекс | В этом задании: если входной параметр меньше 0, функция сразу возвращает `-1` — такого индекса не существует. |
| Переполнение (overflow) | При больших индексах значение может выйти за максимально возможное для конкретного типа данных. В этой задаче это игнорируется. <br>**Пример:** `uint8` может хранить числа 0–255. Если сложить 250 + 10, получится 260 → компьютер берет остаток от деления на 256 → 260 % 256 = 4; число “заворачивается” и становится 4.<br>Подробнее: [Wikipedia](https://ru.wikipedia.org/wiki/%D0%9F%D0%B5%D1%80%D0%B5%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B1%D1%83%D1%84%D0%B5%D1%80%D0%B0) |

---

### Как работает стек вызовов при рекурсии

Каждый вызов `RecursiveFibonacci(n)` создаёт новый уровень стека.  
Функция вызывает сама себя дважды — для `(n-1)` и `(n-2)`.  
Это создаёт рекурсивное дерево, где каждая вершина снова вызывает две ветви до тех пор,  
пока не достигнут базовый случай (`index == 0` или `index == 1`).

Пример: `RecursiveFibonacci(4)`

```
            Fib(4)
          /        
       Fib(3)      Fib(2)
      /            /   
   Fib(2)  Fib(1) Fib(1) Fib(0)
   /   
Fib(1) Fib(0)
```

После достижения base case, дерево начинает сворачиваться обратно, возвращая частичные суммы вверх по дереву вызовов.

---

## Логика и пошаговый разбор кода

### 1. Объявление функции

```go
func RecursiveFibonacci(index int) int {
```

Функция принимает всего один параметр:
- `index int` — позиция в последовательности Фибоначчи (начиная с 0).

---

### 2. Обработка частных случаев

```go
	if index < 0 {
		return -1
	}
	if index == 0 {
		return 0
	}
	if index == 1 {
		return 1
	}
```

- Если `index < 0` → возвращаем `-1` (ошибка по условию).  
- Если `index == 0` → возвращаем `0`.  
- Если `index == 1` → возвращаем `1`.  

Это базовые случаи которые прекращают рекурсию.

---

### 3. Рекурсивная формула

```go
	return RecursiveFibonacci(index-1) + RecursiveFibonacci(index-2)
```

Каждый вызов функции порождает два новых вызова, пока не достигнуты базовые случаи.  
Каждая ветвь вычисляет своё значение, и затем результаты суммируются.

---

### 4. Пример вычисления

```
RecursiveFibonacci(5)
= RecursiveFibonacci(4) + RecursiveFibonacci(3)
= (RecursiveFibonacci(3) + RecursiveFibonacci(2)) + (RecursiveFibonacci(2) + RecursiveFibonacci(1))
= ...
```

В конце базовые случаи дают:  
`Fib(1)=1`, `Fib(0)=0`,  
и программа складывает их, возвращая финальное значение `5`.

---

## Визуализация 

```
Fib(5)
├── Fib(4)
│   ├── Fib(3)
│   │   ├── Fib(2)
│   │   │   ├── Fib(1)
│   │   │   └── Fib(0)
│   │   └── Fib(1)
│   └── Fib(2)
│       ├── Fib(1)
│       └── Fib(0)
└── Fib(3)
    ├── Fib(2)
    │   ├── Fib(1)
    │   └── Fib(0)
    └── Fib(1)
```

Каждая ветвь вызывает две новые функции, пока не дойдёт до 0 и 1 которые потом сложатся.

---

## Заключение

- Рекурсия в этой задаче демонстрирует **разветвляющиеся вызовы** и важность базовых условий.  
- Несмотря на то что выглядит компактно и элегантно, она создаёт много лишних, повторнеых вычислений - обратите внимание, что блоки на дереве повторяются. 
- Поэтому, эффективность рекурсивного Фибоначчи будет крайне низкой для больших индексов. Чтобы ускорить ее можно использовать **мемоизацию** (сохранение уже вычисленных значений).  

Посмотреть как повторяются одни и те же вызовы можно здесь:  
Recursion Tree Visualizer (Fibonacci Example) https://recursion.vercel.app