# Quest 4.9 Eight Queens

## Название файла Go
`eightqueens.go`

---

## Условия задания

| **Instruction** | **Перевод** |
|------------------|--------------|
| *Write a function that prints the solutions to the eight queens puzzle. Recursivity must be used to solve this problem. Each solution will be on a single line. The index of the placement of a queen starts at 1. It reads from left to right and each digit is the position for each column. The solutions will be printed in ascending order.* | *Напишите функцию, которая выводит все решения задачи о восьми ферзях. Для решения нужно использовать рекурсию. Каждое решение должно быть выведено в отдельной строке. Индексация начинается с 1: позиция в строке соответствует номеру столбца, а цифра — номеру строки. Решения должны печататься в порядке возрастания.* |

---

## Что нужно сделать

Нужно написать программу, которая **распечатает все правильные варианты расположения восьми ферзей** на шахматной доске 8×8 так, чтобы они **не били друг друга**.

---

### Правила задачи

- Ферзь атакует по:
  - строкам,
  - столбцам,
  - диагоналям.  
- Поэтому никакие два ферзя **не могут стоять** в одной строке, одном столбце или на одной диагонали.

Пример формата вывода:
```
15863724
16837425
17468253
...
```
Здесь каждая строка — одно решение.  
Например, `15863724` означает:
- в 1-м столбце ферзь стоит в 1-й строке,  
- во 2-м — в 5-й,  
- в 3-м — в 8-й,  
и так далее.

---

## Логика задачи

Чтобы ферзи не конфликтовали по столбцам,  
мы ставим **по одному ферзю в каждый столбец**.  
Остаётся убедиться, что они не пересекаются по строкам и диагоналям.

---

### Основная идея — рекурсивный перебор (бэктрекинг)

1. Двигаемся **по столбцам слева направо (0 → 7)**.  
2. Для каждого столбца пробуем поставить ферзя в одну из 8 строк.  
3. Если позиция безопасна — сохраняем её и **уходим в рекурсию** в следующий столбец.  
4. Если в каком-то столбце ни одна строка не подходит — **откатываемся** назад и пробуем следующую строку для предыдущего столбца.  
5. Когда `col == 8`, значит все ферзи расставлены правильно — печатаем решение.

---

## Проверка безопасности позиции

Две позиции конфликтуют, если:
- они в одной строке (`board[c] == row`),
- или на одной диагонали (`abs(board[c] - row) == col - c`).

Для текущего столбца `col` нужно проверить все предыдущие `c = 0..col-1`.

---

## Почему решения идут в возрастающем порядке

Потому что перебор строк всегда идёт **от 1 до 8** для каждого столбца,  
а столбцы тоже идут слева направо —  
такая рекурсия естественным образом даёт **лексикографически отсортированные** комбинации.

---

## Ключевые понятия

| **Термин** | **Объяснение** |
|-------------|----------------|
| **Backtracking (бэктрекинг)** | Метод поиска, в котором мы поочерёдно пробуем варианты и откатываемся назад, если путь не подходит. Очень часто используется при решении задач типа Constraint Satisfaction Problem, например восьми ферзей или судоку. |
| **Рекурсия (recursion)** | Функция вызывает саму себя, но с другими параметрами. Здесь — чтобы перейти к следующему столбцу. |
| **Базовый случай** | Условие, при котором рекурсия останавливается (здесь `col == 8`). В этот момент найдено полное решение. |
| **Диагонали** | Две клетки находятся на одной диагонали, если разница по строкам равна разнице по столбцам: `|row1 - row2| == |col1 - col2|`. |

---

## Как работает стек вызовов при рекурсии

Каждый рекурсивный вызов функции `PlaceQueen` добавляет **новый уровень в стек**.  
Когда текущий вызов завершается, программа **возвращается** на предыдущий уровень и продолжает с оставшихся вариантов.  

Этот механизм позволяет программе “запоминать”, где она остановилась, и продолжать поиск дальше, не теряя контекст.

---

## Решение

```go
package piscine

import "github.com/01-edu/z01"

func EightQueens() {
	var board [8]int
	placeQueen(board, 0)
}

func placeQueen(board [8]int, col int) {
	if col == 8 {
		printSolution(board)
		return
	}
	for row := 1; row <= 8; row++ {
		if isSafe(board, col, row) {
			board[col] = row
			placeQueen(board, col+1)
		}
	}
}

func isSafe(board [8]int, col, row int) bool {
	for c := 0; c < col; c++ {
		if board[c] == row || abs(board[c]-row) == col-c {
			return false
		}
	}
	return true
}

func printSolution(board [8]int) {
	for i := 0; i < 8; i++ {
		z01.PrintRune(rune(board[i] + '0'))
	}
	z01.PrintRune('\n')
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}
```

---

## Пример работы

При запуске:
```
$ go run .
15863724
16837425
17468253
...
```
Каждая строка — одно из корректных решений задачи о 8 ферзях.

---

## Логика и пошаговый разбор кода

### 1. Объявление основной функции

```go
func EightQueens() {
	var board [8]int
	placeQueen(board, 0)
}
```

- Объявляем основную функцию `EightQueens`.  
- Создаём массив `board` длиной 8 — в нём будет храниться текущая расстановка ферзей.  
  - Индекс массива (`col`) — это номер столбца.  
  - Значение `board[col]` — это номер строки, где стоит ферзь.  
- Запускаем рекурсивную функцию `placeQueen`, начиная с первой колонки (`0`).

---

### 2. Рекурсивная функция для размещения ферзей

```go
func placeQueen(board [8]int, col int) {
	if col == 8 {
		printSolution(board)
		return
	}
	for row := 1; row <= 8; row++ {
		if isSafe(board, col, row) {
			board[col] = row
			placeQueen(board, col+1)
		}
	}
}
```

#### Что здесь происходит:

1. **Проверка базового случая**
   ```go
   if col == 8 {
       printSolution(board)
       return
   }
   ```
   - Если `col == 8`, значит мы успешно поставили 8 ферзей.  
   - Печатаем готовое решение и выходим из рекурсии.  
   - Это и есть **базовый случай рекурсии** — условие выхода.

2. **Основной цикл по строкам**
   ```go
   for row := 1; row <= 8; row++ {
   ```
   - Перебираем возможные строки от 1 до 8 для текущего столбца.

3. **Проверка безопасности позиции**
   ```go
   if isSafe(board, col, row) {
   ```
   - Проверяем, не атакуют ли уже стоящие ферзи новую позицию.

4. **Рекурсивный вызов**
   ```go
   board[col] = row
   placeQueen(board, col+1)
   ```
   - Сохраняем выбранную позицию.  
   - Переходим к следующему столбцу (`col+1`), вызывая ту же функцию.  
   - Когда функция завершится, цикл продолжит пробовать следующие строки.

---

### 3. Проверка безопасности позиции

```go
func isSafe(board [8]int, col, row int) bool {
	for c := 0; c < col; c++ {
		if board[c] == row || abs(board[c]-row) == col-c {
			return false
		}
	}
	return true
}
```

#### Логика проверки:
- Цикл проходит все предыдущие колонки (`c < col`) и проверяет три возможных конфликта:
  1. **По строке:**  
     ```go
     if board[c] == row
     ```  
     Если ферзь уже стоит в этой строке — конфликт.
  2. **По диагонали:**  
     ```go
     abs(board[c]-row) == col-c
     ```  
     Если разница между строками равна разнице между колонками, значит ферзи на одной диагонали.  
     → Конфликт, возвращаем `false`.
- Если конфликтов нет, возвращаем `true`, значит позиция безопасна.

---

### 4. Печать найденного решения

```go
func printSolution(board [8]int) {
	for i := 0; i < 8; i++ {
		z01.PrintRune(rune(board[i] + '0'))
	}
	z01.PrintRune('\n')
}
```

#### Объяснение:
- Проходим по всем 8 колонкам (`i := 0; i < 8; i++`).  
- Для каждой позиции берём `board[i]`, например `5`, и прибавляем `'0'`, чтобы получить символ `'5'`.  
- Выводим эти символы подряд с помощью `z01.PrintRune`.  
- После этого печатаем перевод строки `'\n'`, чтобы каждое решение было на отдельной строке.

---

### 5. Вспомогательная функция `abs`

```go
func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}
```

- Возвращает **модуль числа**, чтобы правильно вычислять разницу между строками при проверке диагоналей.  
- Без этой функции формула проверки `abs(board[c]-row) == col-c` не работала бы корректно для отрицательных разниц.

---

## Визуализация шагов рекурсии

Пример (частичный):  
```
col = 0 → ставим ферзя в строку 1
col = 1 → пробуем строки 1–8 → находим подходящую (5)
col = 2 → пробуем строки 1–8 → ставим (8)
...
col = 8 → найдено решение → печать "15863724"
возврат → откат к предыдущей колонке → пробуем следующие варианты
```

Каждый вызов `placeQueen` это новый уровень рекурсии, а после возврата функция откатывает позицию и пробует следующую строку.

---
## Заключение
Эта задача - классический пример рекурсивного бэктрекинга (пошагового перебора с откатами).  
Каждая функция решает одну подзадачу:  
- `placeQueen` отвечает за рекурсию,  
- `isSafe` проверяет корректность позиции,  
- `printSolution` выводит результат.  
Такой способ разделения делает код более структурным и читаемым.  
Благодаря подобной практике большие задачи можно разбивать на небольшие, независимые части и легко комбинировать их между собой.

