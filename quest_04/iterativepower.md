# Quest 4.3 Iterative Power

## Название файла Go
`iterativepower.go`

---

## Условия задания 

| **Instruction** | **Перевод** |
|---------------------------|--------------|
| *Write an iterative function that returns the value of nb to the power of power. Negative powers will return `0`. Overflows do not have to be dealt with.* | *Напишите функцию которая возвращает значение `nb`  в `power` Возведение в отрицательные степени будет возвращать `0`. Потенциальное переполнение буфера (см. "ключевые понятия") в этом задании можно не учитывать.* |

---

Нужно написать функцию, *которая возводит число в степень*.

### Пример

- **Ввод:** *nb == 3; power == 3*
- **Вывод:** *27*

---
## Решение
```go
package piscine

func IterativePower(nb int, power int) int {
	if power < 0 {
		return 0
	}
	if power == 0 {
		return 1
	}
	if power == 1 {
		return nb
	}

	result := 1

	for i := 1; i <= power; i++ {
		result = result * nb
	}
	return result
}
```

---

## Ключевые понятия

| **Термин или инструмент** | **Объяснение** |
|----------------------------|----------------|
| Цикл `for` | Конструкция, которая позволяет повторять действия несколько раз, пока выполняется определенное условие.<br>Цикл `for` в Go может принимать разные формы.<br>Подробнее: [Metanit](https://metanit.com/go/tutorial/2.10.php) |
| Переменная | Ячейка памяти для хранения данных, например `result`, где мы собираем результат. |
| Условный оператор `if` | Конструкция для выполнения кода только если выполняется определённое условие. |
| Накопление (accumulation) | Постепенное обновление переменной для получения итогового результата. |
| Возврат значения (`return`) | Команда, которая завершает работу функции и отдаёт результат, который она вычислила.<br>**Примечание:** Если написать `return` внутри цикла `for`, то цикл прекратит своё выполнение и функция завершится.<br>`return` подразумевает полное завершение работы для функции. |
| Buffer Overflow (переполнение буфера) | Это случается когда результат вычислений выходит за пределы диапазона типа данных.<br>**Пример:** `uint8` может хранить числа 0–255. Если сложить 250 + 10, получится 260 → компьютер берет остаток от деления на 256 → 260 % 256 = 4; число “заворачивается” и становится 4.<br>Подробнее: [Wikipedia](https://ru.wikipedia.org/wiki/%D0%9F%D0%B5%D1%80%D0%B5%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B1%D1%83%D1%84%D0%B5%D1%80%D0%B0) |


---

## Логика и пошаговый разбор кода

### 1. Объявление функции

```go
func IterativePower(nb int, power int) int {
```
Эта строка объявляет функцию **IterativePower**, которая принимает 2 параметра:

- `nb int` — натуральное число возводимое в степень
- `power int` — степень

### 2. Прописываем все частные правила возведения в степень

```go
    if power < 0 {
        return 0
    }
    if power == 0 {
        return 1
    }
    if power == 1 {
        return nb
    }
```
### 3. Перед открытием цикла, инициализируем переменную для хранения 
Новая переменная нужна чтобы накапливать результат умножений при каждом шаге цикла.

```
    result := 1
```
Если писать `nb = nb * nb`, число каждый раз будет возводиться в квадрат, а не умножаться на исходное nb. \
После первой итерации мы теряем первоначальное значение `nb`. Поэтому нам нужен `result`.

**Примечание:** если создать новую переменную внутри цикла, ее значение так же будет переписываться на первоначально заданное при каждой итерации. Поэтому переменная находится вне цикла!


### 3. Операции в цикле и возврат результата после выхода
```
    for i := 1; i <= power; i++ {
        result = result * nb
    }
    return result
```
Умножение на `nb` должно произойти ровно `power` раз. `i` отслеживает сколько раз мы умножили result на nb чтобы остановить нас вовремя (до нужной нам степени `power`)

**Например если если `nb` = 3 и `power` = 3:** \
    `i=1`: result = 1, `nb = 3`; `result` = 1 * 3 = 3 \
    `i=2`: ранее result обновился и уже = 3; `result` = 3 * 3 = 9 \
    `i=3`: result = 9, новый (финальный) `result` = 9 * 3 = 27 

Как только становится невозможно выполнить условие `i <= power`, цикл заканчивается и мы возвращаем результат nb^power. 

---
## Заключение
- Итеративное возведение в степень учит работать с циклами и счетчиками.
- Понимание таких базовых операций как цикл, накопление и возвращение значения важно для построения более сложных алгоритмов.
- Нужно учитывать частные случаи, чтобы функция работала корректно для всех входных данных. Частные случаи (такие как степень < 0, 0 или 1) можно обрабатывать отдельно для упрощения кода.