# Quest 4.1 Iterative Factorial

## Название файла Go
`iterativefactorial.go`

---

## Условия задания

| **Instruction** | **Перевод** |
|---------------------------|--------------|
| *Write an iterative function that returns the factorial of the `int` passed as parameter. Errors (non possible values or overflows) will return `0`.* | *Напишите **итеративную функцию**, которая возвращает факториал числа, переданного в качестве параметра. В случае ошибок (например, отрицательных значений или переполнения) функция должна вернуть `0`.* |

---

Нужно написать функцию, которая **вычисляет факториал числа** с помощью цикла, а не рекурсии.

### Пример выполнения

| Входное значение | Вычисление | Результат |
|------------------|-------------|------------|
| 0 | 0! = 1 | 1 |
| 1 | 1! = 1 | 1 |
| 3 | 1×2×3 | 6 |
| 5 | 1×2×3×4×5 | 120 |
| -4 | отрицательное | 0 |

---

## Решение

```go
package piscine

func IterativeFactorial(nb int) int {
	if nb < 0 {
		return 0
	}
	result := 1
	for i := 1; i <= nb; i++ {
		result *= i
		if result < 0 {
			return 0
		}
	}
	return result
}
```

---

## Ключевые понятия

| **Термин или инструмент** | **Объяснение** |
|----------------------------|----------------|
| **Факториал (Factorial)** | Произведение всех целых чисел от 1 до данного числа включительно. Обозначается как `n!`.<br>Например: 5! = 1 × 2 × 3 × 4 × 5 = 120. |
| Цикл `for` | Конструкция, которая позволяет повторять действия несколько раз, пока выполняется определенное условие.<br>Цикл `for` в Go может принимать разные формы.<br>Подробнее: [Metanit](https://metanit.com/go/tutorial/2.10.php) |
| **Итерация (Iteration)** | Повторение одного и того же действия — например, умножение переменной на очередное число в цикле. |
| **Переменная** | Ячейка памяти для хранения данных, например `result`, где мы собираем результат. |
| **Накопление (accumulation)** | Постепенное обновление переменной для получения итогового результата. |
| **Условный оператор `if`** | Конструкция для выполнения кода только если выполняется определённое условие. |
| **Возврат значения (`return`)** | Команда, которая завершает работу функции и отдаёт результат, который она вычислила.<br>**Примечание:** Если написать `return` внутри цикла `for`, то цикл прекратит своё выполнение и функция завершится.<br>`return` подразумевает полное завершение работы для функции. |
| **Buffer Overflow (переполнение буфера)** | Это случается когда результат вычислений выходит за пределы диапазона типа данных.<br>**Пример:** `uint8` может хранить числа 0–255. Если сложить 250 + 10, получится 260 → компьютер берет остаток от деления на 256 → 260 % 256 = 4; число “заворачивается” и становится 4.<br>Подробнее: [Wikipedia](https://ru.wikipedia.org/wiki/%D0%9F%D0%B5%D1%80%D0%B5%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B1%D1%83%D1%84%D0%B5%D1%80%D0%B0) |
---

## Логика и пошаговый разбор кода

### 1. Объявление функции

```go
func IterativeFactorial(nb int) int {
```

Функция принимает одно целое число `nb` и возвращает `int` — значение факториала.

---

### 2. Проверка на некорректные входные значения

```go
if nb < 0 {
	return 0
}
```

- Если число отрицательное, факториалa не существует, возвращаем `0`.  
- `0! == 1`, поэтому ниже цикл просто не запустится, и `result` останется `1`.

---

### 3. Переменная для накопления результата

```go
result := 1
```

Эта переменная будет хранить промежуточный результат после каждой итерации.

---

### 4. Цикл вычислений

```go
for i := 1; i <= nb; i++ {
	result = result * i
	if result < 0 {
		return 0
	}
}
```

- Переменная `i` — счётчик от 1 до `nb`.  
- На каждом шаге перемножаем `result` и `i`.  
- Если результат стал отрицательным, значит произошел buffer overflow, и функция возвращает `0`.

---

### 5. Возврат результата

```go
return result
```

После завершения цикла возвращается значение факториала.

---

## Визуализация итераций

```
nb = 5
result = 1

i = 1 → result = 1 * 1 = 1
i = 2 → result = 1 * 2 = 2
i = 3 → result = 2 * 3 = 6
i = 4 → result = 6 * 4 = 24
i = 5 → result = 24 * 5 = 120
→ return 120
```

---

## Заключение

- Задание учит работать с циклами и счетчиками.
- Понимание таких базовых операций как цикл, накопление и возвращение значения важно для построения более сложных алгоритмов.
- Нужно учитывать частные случаи, чтобы функция работала корректно для всех входных данных. Частные случаи можно обрабатывать отдельно для упрощения кода.