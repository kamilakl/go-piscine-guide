# Quest 4.4 Recursive Power

## Название файла Go
`recursivepower.go`

---

## Условия задания

| **Instruction** | **Перевод** |
|---------------------------|--------------|
| *Write a recursive function that returns the value of nb to the power of power. Negative powers will return 0. Overflows do not have to be dealt with.* | *Напишите **рекурсивную функцию**, которая возвращает значение `nb` в степени `power`. Для отрицательных степеней возвращайте `0`. Потенциальные переполнения учитывать не нужно.* |

---

Нужно написать **рекурсивную** функцию, которая вычисляет `nb^power` (число `nb`, возведённое в степень `power`).

### Пример

- **Ввод:** `nb == 2; power == 4`  
- **Вывод:** `16`

---

## Решение
```go
package piscine

func RecursivePower(nb int, power int) int {
	if power < 0 {
		return 0
	}
	if power == 0 {
		return 1
	}
	return nb * RecursivePower(nb, power-1)
}
```

---

## Ключевые понятия
| **Термин или инструмент** | **Объяснение** |
|----------------------------|----------------|
| Рекурсия | Это процесс, когда функция вызывает сама себя, пока не достигнет определённого условия (базового случая). |
| Базовый случай (base case) | Условие, при котором рекурсивные вызовы прекращаются. Без него программа зациклится. |
| Возврат значения (`return`) | Возвращает результат вычисления из функции. В рекурсивных вызовах это важно для накопления результата из всех предыдущих уровней вызова. |
| Buffer Overflow (переполнение буфера) | Это случается когда результат вычислений выходит за пределы диапазона переменной.<br>**Пример:** `uint8` может хранить числа 0–255. Если сложить 250 + 10, получится 260 → компьютер берет остаток от деления на 256 → 260 % 256 = 4; число “заворачивается” и становится 4.<br>Подробнее: [Wikipedia](https://ru.wikipedia.org/wiki/%D0%9F%D0%B5%D1%80%D0%B5%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B1%D1%83%D1%84%D0%B5%D1%80%D0%B0) |
| **Стек вызовов (Call Stack)** | Это структура данных, где программа хранит информацию обо всех активных функциях. <br> Когда функция вызывается, в стек помещается её “фрейм” (данные вызова). Когда функция завершается, её фрейм удаляется со стека. |
| **Фрейм вызова (Stack Frame)** | Это блок памяти, в котором хранятся параметры функции, её локальные переменные и адрес возврата (куда вернуться после завершения). <br>При каждом рекурсивном вызове создаётся новый фрейм, который кладётся **на вершину стека**. Когда функция достигает базового случая, начинается “раскрутка”: фреймы удаляются в обратном порядке, и возвращаются результаты. |
---

### Как работает стек вызовов при рекурсии

Когда программа вызывает функцию, она **сохраняет информацию о текущем месте выполнения** и переходит внутрь функции.  
Эта информация (параметры функции, локальные переменные, адрес возврата) помещается в  **стек вызовов (call stack)**.

Рассмотрим пример: `RecursivePower(2, 3)`

1. Главная программа вызывает `RecursivePower(2, 3)`.  
   В стек помещается первый фрейм — данные этого вызова.
2. Внутри функции вызывается `RecursivePower(2, 2)` → создаётся новый фрейм (ещё один уровень стека).
3. Затем `RecursivePower(2, 1)` → новый фрейм.
4. Потом `RecursivePower(2, 0)` → базовый случай → возвращаем `1`.

Теперь начинается раскрутка:
- Функция с `power = 0` завершилась, её фрейм удаляется.
- Функция с `power = 1` получает результат, вычисляет `2 * 1 = 2` и тоже завершается.
- Функция с `power = 2` получает `2`, считает `2 * 2 = 4`.
- И, наконец, `RecursivePower(2, 3)` возвращает `2 * 4 = 8`.

Когда стек опустошается, рекурсия завершена.

---

## Логика и пошаговый разбор кода

### 1. Объявление функции

```go
func RecursivePower(nb int, power int) int {
```

Функция принимает два параметра:
- `nb int` — число,
- `power int` — степень, в которую возводим число.

---

### 2. Обработка частных случаев

```go
	if power < 0 {
		return 0
	}
	if power == 0 { // базовый случай! (см. ниже)
		return 1
	}
```

- Если степень отрицательная → возвращаем `0` по условию задачи.  
- Если степень равна `0` → любое число в нулевой степени равно `1`.

---

### Базовый случай

Когда функция доходит до этого момента, она **не вызывает себя снова**, а просто возвращает значение.  
После этого все предыдущие вызовы получают результат и раскручиваются обратно, пока стек вызовов не освободится.

---

### 3. Рекурсивное выражение

```go
	return nb * RecursivePower(nb, power-1)
```

Главная идея это **выразить задачу через саму себя**, уменьшая показатель степени каждый раз на 1.

Каждый вызов функции делает лишь одну операцию умножения и передаёт задачу глубже, пока не достигнет базового случая (`power == 0`).

---

### 4. Пример выполнения

**Пусть `nb = 2`, `power = 3`:**
```
RecursivePower(2, 3)
│
├── 2 * RecursivePower(2, 2)
│     ├── 2 * RecursivePower(2, 1)
│     │     ├── 2 * RecursivePower(2, 0)
│     │     └── 1  ← базовый случай
│     └── 2 * 1 = 2
└── 2 * 2 = 4
Результат: 8
```
---

## Заключение

- Рекурсия позволяет заменять циклы за счёт повторных вызовов функции.  
- Важно всегда **иметь базовый случай**, чтобы избежать бесконечной рекурсии.  
- Эта задача помогает понять, как функции могут взаимодействовать с самими собой и как раскручивается стек вызовов при возвратах. 

Визуализация рекурсии: https://recursion.vercel.app  

### Примечания

Использование рекурсии может быть **менее оптимальным**, поскольку для каждого вызова функции создаётся **новый фрейм (frame)** в **стеке вызовов (call stack)**. 
Каждый вызов требует выделения памяти под новый фрейм в стеке (локальные переменные, аргументы, адрес возврата), а это занимает время и память. 
В некоторых рекурсивных алгоритмах (например Фибоначчи) одни и те же значения пересчитываются по много раз: `Fib(n) = Fib(n-1) + Fib(n-2)` 
При больших значениях это может привести к **переполнению стека (stack overflow)** или к дополнительным затратам по времени и памяти.  

---
