# Quest 4.7 Is Prime 

## Название файла Go
`isprime.go`

---

## Условия задания

| **Instruction** | **Перевод** |
|---------------------------|--------------|
| *Write a function that returns `true` if the `int` passed as parameter is a prime number. Otherwise it returns `false`. The function must be optimized in order to avoid time-outs with the tester. (We consider that only positive numbers can be prime numbers) (We also consider that 1 is not a prime number).* | *Напишите функцию, которая возвращает `true`, если переданное целое число является простым (prime number), и `false` — если нет. Функция должна быть оптимизирована, чтобы избежать тайм-аута. Мы считаем, что только положительные числа могут быть простыми, а число 1 не является простым.* |

---

Нужно написать функцию, которая **определяет, простое число или нет**.

### Пример 

| Входное значение | Проверка | Результат |
|------------------|-----------|------------|
| 2 | Простое (единственное чётное) | true |
| 3 | Делителей нет | true |
| 4 | Делится на 2 | false |
| 9 | Делится на 3 | false |
| 17 | Делителей нет | true |
---

## Решение

```go
package piscine

func IsPrime(nb int) bool {
	if nb <= 1 {
		return false
	}
	if nb == 2 {
		return true
	}
	if nb%2 == 0 {
		return false
	}
	for i := 3; i*i <= nb; i += 2 {
		if nb%i == 0 {
			return false
		}
	}
	return true
}
```

---

## Ключевые понятия

| **Термин или инструмент** | **Объяснение** |
|----------------------------|----------------|
| **Prime number (простое число)** | Натуральное число, которое делится **только на 1 и само на себя**.<br>Примеры: 2, 3, 5, 7, 11, 13, 17, 19.<br>Противоположное понятие — *composite number (составное число)*. |
| **Composite number (составное число)** | Число, которое можно разделить на другие делители, кроме 1 и самого себя.<br>Например, 9 = 3 × 3, 15 = 3 × 5. |
| **Boolean (булев тип)** | Тип данных, который может принимать только одно из двух состояний:<br>**true** (истина, “да”) или **false** (ложь, “нет”).<br> Представьте что мы даем условие компьютеру: "Если произошло событие X, то сделай Y". <br> С помощью булевой переменной компьютер поймёт, произошло ли Х вообще. В Go пишется с маленькой буквы: `true`, `false`. |
| **Оператор `%` (остаток от деления)** | Возвращает остаток от деления двух чисел.<br>Например: `7 % 3 = 1`, `10 % 2 = 0`.<br>Если остаток равен 0, значит число делится нацело. |

---

## Как прописать оптимизированную проверку на простоту

Когда мы проверяем, простое ли число, мы должны убедиться, что у него **нет других делителей, кроме 1 и самого себя**.  
Но проверять все числа до `nb` не нужно — достаточно идти **до квадратного корня** числа.

Почему?  
Если число имеет делитель, то один из пары делителей всегда меньше или равен квадратному корню.

**Пример:**  
- Для числа 56,  √56 ≈ 7.48.  
- Пары делителей: (1, 56), (7, 8), (2, 28), (4, 14).  
В каждой паре один делитель ≤ 7.48, а второй ≥ 7.48.  
Поэтому достаточно проверить только до корня — если не нашли делителей, значит их нет вообще.

---

## Логика и пошаговый разбор кода

### 1. Объявление функции

```go
func IsPrime(nb int) bool {
```

Функция принимает один аргумент:
- `nb int` — число для проверки.  
Возвращает тип **bool**, который равен `true` если число простое, и `false` — если нет.

---

### 2. Проверка исключений и простых случаев

```go
if nb <= 1 {
	return false
}
if nb == 2 {
	return true
}
if nb%2 == 0 {
	return false
}
```

- Все числа меньше или равные 1 не считаются простыми.  
- Число 2 — единственное четное простое число.  
- Остальные чётные числа (`%2 == 0`) являются составными.

Таким образом мы избавляемся от необходимости проверки четных чисел и чисел меньше (и равно) 2

---

### 3. Цикл проверки оставшихся делителей

```go
for i := 3; i*i <= nb; i += 2 {
	if nb%i == 0 {
		return false
	}
}
```

- Проверяем только нечетные делители, начиная с 3. Шаг определяется как `i += 2`  чтобы перепрыгнуть четные потенциальные делители (i=3; i=5, etc.)
- Условие выхода: `i*i <= nb` (до квадратного корня).  
- Если число делится нацело на хоть один `i`, то оно составное, возвращаем `false`.  

Если цикл завершился без возврата, значит делителей не найдено.

---

### 4. Завершение функции

```go
return true
```

Если все проверки пройдены (первые со специальными условиями, а затем в цикле), число действительно простое, поэтому возвращаем `true`.

---

## Заключение

В условиях требовалось, чтобы функция была оптимизирована:
- Пропуск четных чисел ускоряет проверку вдвое, так как проверять четные делители нет смысла после 2.
- Проверка до квадратного корня уменьшает количество итераций с `O(n)` до `O(√n)` (прим.: термин *time complexity алгоритмов*). Мы не перебираем все числа до `nb`, а только до `√nb`.

Пример прироста скорости и масштабируемости: для числа 1 000 000 мы проверим около 500 делителей вместо миллиона.

**Данное задание показывает, что качественный анализ входных условий позволяет ускорить работу программы в десятки раз.**

---