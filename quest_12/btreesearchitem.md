# Quest 12.5. btreesearchitem

## Название файла Go

`btreesearchitem.go`

---

## Условия задания

| **Instruction**                                                                                                              | **Перевод**                                                                                                        |
| ---------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------ |
| *Write a function that returns the TreeNode with a data field equal to elem if it exists in the tree, otherwise return nil.* | *Напишите функцию, которая возвращает узел дерева, чей `Data` равен `elem`. Если такого узла нет — вернуть `nil`.* |

---

Нужно написать функцию, которая **ищет элемент в бинарном дереве поиска (BST)** и возвращает **сам узел**, если он найден.

Если нужного элемента нет → возвращаем `nil`.

### Пример

* **Ввод:**

```go
root := &piscine.TreeNode{Data: "4"}
piscine.BTreeInsertData(root, "1")
piscine.BTreeInsertData(root, "7")
piscine.BTreeInsertData(root, "5")

selected := piscine.BTreeSearchItem(root, "7")
```

* **Вывод:**

```
Item selected -> 7
Parent of selected item -> 4
Left child of selected item -> 5
Right child of selected item -> nil
```

---

## Решение

```go
package piscine

func BTreeSearchItem(root *TreeNode, elem string) *TreeNode {
	if root == nil {
		return nil
	}

	if root.Data == elem {
		return root
	} else if elem < root.Data {
		return BTreeSearchItem(root.Left, elem)
	} else {
		return BTreeSearchItem(root.Right, elem)
	}
}
```

---

## Ключевые понятия

| **Инструмент / элемент кода**            | **Объяснение и назначение**                                                                |
| ---------------------------------------- | ------------------------------------------------------------------------------------------ |
| **Пакет (`package ...`)**                | Группирует файл в модуль, который можно импортировать в другом коде.                       |
| **Binary Search Tree (BST)**             | Дерево, где слева элементы меньше, справа — больше. Идеально подходит для быстрого поиска. |
| **Узел (`TreeNode`)**                    | Элемент дерева, который содержит `Data`, `Left`, `Right`, `Parent`.                        |
| **Рекурсия**                             | Функция вызывает сама себя, переходя вниз по дереву.                                       |
| **Сравнение строк (`elem < root.Data`)** | Определяет, в какую сторону идти — влево или вправо.                                       |
| **Поиск элемента**                       | Если значение равно — возвращаем узел; если меньше — идём влево; если больше — вправо.     |
| **Возврат `nil`**                        | Означает: искомого элемента нет в дереве.                                                  |

---

## Логика и пошаговый разбор кода

### 1. Объявление функции

```go
func BTreeSearchItem(root *TreeNode, elem string) *TreeNode {
```

Эта строка объявляет функцию **BTreeSearchItem**, которая:

* принимает:

  * `root` — корень дерева (или текущий узел при рекурсии)
  * `elem` — строка, которую ищем
* возвращает:

  * `*TreeNode` — найденный узел или `nil`, если его нет

---

### 2. Базовый случай: если узел пустой

```go
if root == nil {
	return nil
}
```

Если дерево пустое → искать нечего.

Если при рекурсии мы дошли до пустой ветки → значит, элемента **нет**.

**Возвращаем `nil`.**

---

### 3. Проверяем: найден ли элемент

```go
if root.Data == elem {
	return root
}
```

Если текущий узел содержит нужное значение:

* поиск завершён
* возвращаем указатель на этот узел

---

### 4. Решаем, в какую сторону идти — влево или вправо

```go
else if elem < root.Data {
	return BTreeSearchItem(root.Left, elem)
}
```

Если `elem` **меньше** — идём в левую ветку.

```go
else {
	return BTreeSearchItem(root.Right, elem)
}
```

Если `elem` **больше** — переходим в правую ветку.

Это работает благодаря правилу BST:

* всё меньшие значения — слева
* всё большие — справа

---

## Как работает поиск на примере

После вставки значений:

```
        4
      /   \
     1     7
          /
         5
```

Вызов:

```go
selected := BTreeSearchItem(root, "7")
```

Идёт так:

1. Сравниваем `"7"` с `"4"`
   → `"7" > "4"` → идём вправо
2. Сравниваем `"7"` с `"7"`
   → равно → элемент найден
   → возвращаем узел `"7"`

Структура найденного узла:

```
    7
   /
  5
```

Это полностью соответствует выводу из примера.

---

## Глоссарий

| **Термин**            | **Понятное объяснение**                                |
| --------------------- | ------------------------------------------------------ |
| **BST**               | Бинарное дерево поиска: структура для быстрого поиска. |
| **Поиск**             | Процесс нахождения узла, чьё значение равно `elem`.    |
| **Рекурсивный вызов** | Функция вызывает себя для левого или правого ребёнка.  |
| **nil**               | Пустое значение. Возвращается, если элемент не найден. |
| **Left / Right**      | Указатели на левых и правых детей узла.                |
| **Data**              | Поле, в котором хранится значение узла.                |

---

## Заключение

Главное, что нужно запомнить:

* Поиск в BST работает за **O(log n)** (если дерево сбалансировано).
* Проверяем:

  1. Если узел пустой — результата нет.
  2. Если значение совпало — успех.
  3. Если искомое меньше — идём влево.
  4. Если больше — вправо.
* Рекурсия делает код компактным и логичным.
* Возвращаем **сам узел**, а не его значение — это важно.
