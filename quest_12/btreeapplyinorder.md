# Quest 12.2. btreeapplyinorder

## Название файла Go
`btreeapplyinorder.go`

---

## Условия задания 

| **Instruction** | **Перевод** |
|---------------------------|--------------|
| *Write a function that applies a given function f, in order, to each element in the tree.* | *Напишите функцию, которая применяет заданную функцию f по порядку к каждому элементу дерева.* |

---

Нужно написать функцию, которая *обходит дерево "по порядку"*.
Основная функция должна быть такой:

```go
func BTreeApplyInorder(root *TreeNode, f func(...interface{}) (int, error)) {

}
```

### Пример

- **Ввод:** 

```go
package main

import (
	"fmt"
	"piscine"
)

func main() {
	root := &piscine.TreeNode{Data: "4"}
	piscine.BTreeInsertData(root, "1")
	piscine.BTreeInsertData(root, "7")
	piscine.BTreeInsertData(root, "5")
	piscine.BTreeApplyInorder(root, fmt.Println)

}
```

- **Вывод:** 

```go
$ go run .
1
4
5
7
$
```

---

## Решение

```go
package piscine

func BTreeApplyInorder(root *TreeNode, f func(...interface{}) (int, error)) {
	if root == nil {
		return
	}

	BTreeApplyInorder(root.Left, f)

	f(root.Data)

	BTreeApplyInorder(root.Right, f)
}
```

---

## Ключевые понятия

| **Инструмент / элемент кода**                                    | **Объяснение и назначение**                                                                                       |
| ---------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------- |
| **Пакет (`package piscine`)**                                    | Объединяет код в модуль, который можно импортировать из других файлов (например, из `main`).                      |
| **`type TreeNode struct { ... }`**                               | Описывает один узел бинарного дерева: данные (`Data`) и ссылки на соседей (`Left`, `Right`, `Parent`).            |
| **Бинарное дерево поиска (BST)**                                 | Структура, где у каждого узла: слева — элементы меньше, справа — элементы больше.                                 |
| **Обход in-order**                                               | Порядок обхода узлов: **лево → текущий узел → право**. В BST даёт **отсортированный** вывод.                      |
| **Функция как аргумент (`f func(...interface{}) (int, error)`)** | Мы передаём в `BTreeApplyInorder` другую функцию (например, `fmt.Println`), и она будет вызвана для каждого узла. |
| **Рекурсия**                                                     | Функция вызывает саму себя, чтобы обойти левое и правое поддеревья.                                               |
| **Проверка `if root == nil`**                                    | Базовый случай рекурсии: если узла нет — выходим, ничего не делаем.                                               |

---

## Логика и пошаговый разбор кода
---

### 1. Объявление функции

```go
func BTreeApplyInorder(root *TreeNode, f func(...interface{}) (int, error)) {
```

Эта строка объявляет функцию **BTreeApplyInorder**, которая:

* принимает:

  * `root *TreeNode` — указатель на **корень дерева** (или поддерева);
  * `f func(...interface{}) (int, error)` — **функцию**, которую мы будем применять к данным в каждом узле.

Почему именно такой тип `f`?

* `fmt.Println` как раз имеет сигнатуру:
  `func Println(a ...interface{}) (n int, err error)`
* Поэтому в примере можно спокойно делать:

  ```go
  BTreeApplyInorder(root, fmt.Println)
  ```

---

### 2. Базовый случай рекурсии: нет узла — нет работы

```go
if root == nil {
	return
}
```

**Что здесь происходит:**

* Если `root == nil`, значит:

  * либо дерево пустое,
  * либо мы дошли до "конца ветки" (нет левого/правого ребёнка).
* В таком случае обрабатывать нечего — просто `return`.

Это называется **базовым случаем рекурсии**.
Без него функция вызывала бы саму себя бесконечно.

**Мини-пример в голове:**

Когда мы спускаемся влево:

* пока есть узлы — продолжаем.
* как только дошли до `nil` (нет ребёнка) — выходим и поднимаемся обратно.

---

### 3. Рекурсивный обход левого поддерева

```go
BTreeApplyInorder(root.Left, f)
```

**Логика:**

* Сначала мы вызываем `BTreeApplyInorder` для **левого ребёнка**.
* То есть:

  * “Прежде чем обработать текущий узел, я сначала обойду всё, что слева”.

Это и есть первая часть схемы **in-order**:

> **лево → узел → право**

---

### 4. Применение функции к текущему узлу

```go
f(root.Data)
```

**Что происходит:**

* Здесь мы вызываем переданную функцию `f` и передаём в неё значение текущего узла: `root.Data`.

В примере:

```go
BTreeApplyInorder(root, fmt.Println)
```

Значит на каждом узле фактически выполняется:

```go
fmt.Println(root.Data)
```

То есть данные просто печатаются строкой в консоль.

**Важно:**

* Мы **игнорируем** результат `(int, error)`, который возвращает `f`, потому что нам он в этой задаче не нужен.
* Нам важно только побочное действие — например, вывод на экран.

---

### 5. Рекурсивный обход правого поддерева

```go
BTreeApplyInorder(root.Right, f)
```

После обработки текущего узла мы:

* вызываем `BTreeApplyInorder` для правого ребёнка `root.Right`.

Это завершает схему **in-order**:

1. `BTreeApplyInorder(root.Left, f)` → **лево**
2. `f(root.Data)` → **текущий узел**
3. `BTreeApplyInorder(root.Right, f)` → **право**

---

## Как это работает на примере из задания

Пример:

```go
root := &piscine.TreeNode{Data: "4"}
piscine.BTreeInsertData(root, "1")
piscine.BTreeInsertData(root, "7")
piscine.BTreeInsertData(root, "5")
piscine.BTreeApplyInorder(root, fmt.Println)
```

После всех вставок дерево выглядит так:

```text
        "4"
       /   \
     "1"   "7"
          /
        "5"
```

Теперь запускаем `BTreeApplyInorder(root, fmt.Println)`.

Разберём рекурсивно:

1. `root = "4"`
   → идём влево: `BTreeApplyInorder(root.Left, f)` с узлом `"1"`

2. В узле `"1"`:

   * идём влево: `root.Left == nil` → `return`
   * вызываем `f("1")` → печатается `1`
   * идём вправо: `root.Right == nil` → `return`

   Возвращаемся к `"4"`.

3. В узле `"4"`:

   * левое поддерево уже обработали
   * вызываем `f("4")` → печатается `4`
   * идём вправо: `BTreeApplyInorder(root.Right, f)` с узлом `"7"`

4. В узле `"7"`:

   * идём влево: `BTreeApplyInorder(root.Left, f)` с узлом `"5"`

5. В узле `"5"`:

   * идём влево: `nil` → `return`
   * вызываем `f("5")` → печатается `5`
   * идём вправо: `nil` → `return`

   Возвращаемся к `"7"`.

6. В узле `"7"`:

   * левое поддерево обработано (`"5"`)
   * вызываем `f("7")` → печатается `7`
   * идём вправо: `nil` → `return`

**Фактический порядок вызовов `fmt.Println`:**

1. `"1"`
2. `"4"`
3. `"5"`
4. `"7"`

Вывод:

```text
1
4
5
7
```

Именно это и требуется в примере.

---

## Глоссарий

| **Термин**                   | **Понятное объяснение**                                                                                                        |
| ---------------------------- | ------------------------------------------------------------------------------------------------------------------------------ |
| **Обход дерева (traversal)** | Процесс “обхода” всех узлов дерева в определённом порядке.                                                                     |
| **In-order traversal**       | Обход в порядке: левое поддерево → текущий узел → правое поддерево. В BST даёт **отсортированный список** значений.            |
| **Рекурсия**                 | Когда функция вызывает саму себя для решения более маленькой подзадачи.                                                        |
| **Базовый случай**           | Условие, при котором рекурсия останавливается (здесь — `if root == nil { return }`).                                           |
| **Функция как параметр**     | Мы можем передавать функцию в другую функцию и вызывать её внутри. Это позволяет писать универсальный код.                     |
| **`fmt.Println`**            | Стандартная функция вывода. Подходит как `f` в этом задании, потому что её тип совместим: `func(...interface{}) (int, error)`. |
| **Поддерево**                | Частичка дерева, которая сама является деревом: узел и все его потомки.                                                        |

---

## Что нужно вынести и запомнить из этого задания:

1. **Обход in-order** — это `лево → узел → право`.
   В бинарном дереве поиска такой обход даёт **отсортированный** вывод значений.
2. Мы научились:

   * использовать **рекурсию** для обхода дерева;
   * передавать **функцию как аргумент** и вызывать её для каждого узла;
   * правильно писать базовый случай `if root == nil`.
3. В примере `fmt.Println` — просто частный случай: вместо него можно передать любую функцию с такой же сигнатурой и, например:

   * накапливать значения в срезе,
   * считать количество узлов,
   * делать любую другую обработку.
