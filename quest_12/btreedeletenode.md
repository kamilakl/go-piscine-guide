# Quest 12.12. btreedeletenode

## Название файла Go

`btreedeletenode.go`

---

## Условия задания

| **Instruction**                                                                                                                                          | **Перевод**                                                                                                                          |
| -------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| *Write a function, BTreeDeleteNode, that deletes node from the tree given by root. The resulting tree should still follow the binary search tree rules.* | *Напишите функцию, которая удаляет узел `node` из дерева `root`, и при этом дерево после удаления должно оставаться корректным BST.* |

---

Нужно реализовать классический алгоритм удаления узла в бинарном дереве поиска.

Удаление — самая сложная операция в BST, потому что нужно учитывать **три случая**:

1. У узла нет левого ребёнка
2. У узла нет правого ребёнка
3. У узла оба ребёнка есть — самый сложный случай

---

### Пример

**До удаления:**

```
        4
      /   \
     1     7
          /
         5
```

**Удаляем 4 (корень):**

```
        5
      /   \
     1     7
```

Inorder вывод:

До: `1 4 5 7`
После: `1 5 7`

---

## Решение

```go
package piscine

func BTreeDeleteNode(root, node *TreeNode) *TreeNode {
	if node == nil {
		return root
	}

	if node.Left == nil {
		return BTreeTransplant(root, node, node.Right)
	}

	if node.Right == nil {
		return BTreeTransplant(root, node, node.Left)
	}

	successor := BTreeMin(node.Right)
	if successor.Parent != node {
		root = BTreeTransplant(root, successor, successor.Right)
		successor.Right = node.Right
		if successor.Right != nil {
			successor.Right.Parent = successor
		}
	}
	root = BTreeTransplant(root, node, successor)
	successor.Left = node.Left
	if successor.Left != nil {
		successor.Left.Parent = successor
	}

	return root
}
```

---

## Ключевые понятия

| **Инструмент / элемент кода** | **Объяснение и назначение**                                                          |
| ----------------------------- | ------------------------------------------------------------------------------------ |
| **BST (Binary Search Tree)**  | Удаление должно сохранять свойства BST.                                              |
| **Transplant**                | Операция пересадки поддерева: заменяет один узел другим.                             |
| **3 случая удаления**         | Узел без детей слева, без детей справа, или с двумя детьми.                          |
| **Successor (преемник)**      | Минимальный узел в правом поддереве — используется при удалении узла с двумя детьми. |
| **BTreeMin**                  | Находит самый левый узел — минимальный элемент.                                      |
| **Parent ссылки**             | Нужно правильно обновлять связи между узлами.                                        |
| **Поддерево**                 | Часть дерева, которое начинается с определённого узла.                               |

---

## Логика и пошаговый разбор кода

---

### 1. Проверка: если node = nil

```go
if node == nil {
	return root
}
```

Удалять нечего → возвращаем корень как есть.

---

### 2. Случай 1 — нет левого ребёнка

```go
if node.Left == nil {
	return BTreeTransplant(root, node, node.Right)
}
```

Если слева пусто:

* заменяем узел на его правого ребёнка
* свойство BST сохраняется

Пример:

```
   4
    \
     7
```

Удаляем `4` → `7` становится корнем.

---

### 3. Случай 2 — нет правого ребёнка

```go
if node.Right == nil {
	return BTreeTransplant(root, node, node.Left)
}
```

Если справа пусто:

* заменяем узел на его левого ребёнка

Пример:

```
   4
  /
 2
```

Удаляем `4` → `2` становится корнем.

---

### 4. Случай 3 — есть оба ребёнка (самый сложный)

```go
successor := BTreeMin(node.Right)
```

Мы ищем **преемника** — минимальный элемент из правого поддерева:

```
        4
      /   \
     1     7
          /
         5
```

→ Преемник узла `4` = `5`.

---

### 5. Если преемник НЕ является непосредственным правым потомком

```go
if successor.Parent != node {
	root = BTreeTransplant(root, successor, successor.Right)
	successor.Right = node.Right
	if successor.Right != nil {
		successor.Right.Parent = successor
	}
}
```

Это редкий, но важный случай.

Пример:

```
   4
    \
     7
    /
   5   ← преемник
```

У преемника может быть правый ребёнок, его нужно «поднять».

Шаги:

1. Пересадить преемника на место его правого ребёнка.
2. Присоединить правое поддерево удаляемого узла к преемнику.

---

### 6. Подменяем node → successor

```go
root = BTreeTransplant(root, node, successor)
```

Теперь преемник занимает место удаляемого узла.

---

### 7. Присоединяем левое поддерево удалённого узла

```go
successor.Left = node.Left
if successor.Left != nil {
	successor.Left.Parent = successor
}
```

Теперь преемник полностью занимает место удалённого узла:

* слева — старое левое поддерево
* справа — либо старое правое, либо обновлённое

---

### 8. Возвращаем новый корень

```go
return root
```

---

## Как работает на примере

Удаляем `4`:

```
До:
        4
      /   \
     1     7
          /
         5
```

Шаги:

1. У узла `4` есть оба ребёнка → ищем преемника.
2. Преемник = `5`
3. `5` не прямой ребёнок → поднимаем его.
4. Пересаживаем `4` → `5`
5. Присоединяем левое поддерево `1`

Результат:

```
        5
      /   \
     1     7
```

Вывод inorder:

```
1
5
7
```

---

## Глоссарий

| **Термин**               | **Понятное объяснение**                                             |
| ------------------------ | ------------------------------------------------------------------- |
| **Преемник (successor)** | Следующий элемент в inorder-обходе: минимум в правом поддереве.     |
| **Transplant**           | Замена узла другим узлом или поддеревом.                            |
| **Удаление BST**         | Алгоритм, который должен сохранить структуру поиска.                |
| **Inorder Traversal**    | Обход слева → корень → справа. Для BST даёт отсортированный список. |
| **Parent указатели**     | Нужны для корректных пересадок.                                     |
| **Поддерево**            | Узел и все его потомки.                                             |
| **Два ребёнка**          | Самый сложный случай удаления: требуется поиск преемника.           |

---

## Заключение

Из этого задания важно запомнить:

* Удаление в BST имеет **три сценария**, каждый из которых реализуется корректно.
* Функция **BTreeTransplant** — фундамент для пересборки дерева.
* При удалении узла с двумя детьми используется **преемник**.
* Все связи `Parent`, `Left`, `Right` должны быть корректно перенесены.
* После удаления дерево остаётся валидным BST.
