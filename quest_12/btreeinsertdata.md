# Quest 12.1. btreeinsertdata

## Название файла Go
`btreeinsertdata.go`

---

## Условия задания 

| **Instruction** | **Перевод** |
|---------------------------|--------------|
| *Write a function that inserts new data in a binary search tree following the special properties of a binary search trees. The nodes must be defined as follows : *TreeNode* | *Напишите функцию, которая вставляет новые данные в двоичное дерево поиска, следуя особым свойствам двоичных деревьев поиска. Узлы должны быть определены следующим образом: *TreeNode* |

---

Нужно написать функцию, которая *вставляет новые данные в двоичное дерево поиска*. Узлы должны быть определены вот так:

```go
type TreeNode struct {
	Left, Right, Parent *TreeNode
	Data                 string
}
```

Основная функция должна быть такой:

```go
func BTreeInsertData(root *TreeNode, data string) *TreeNode {

}
```

### Пример

- **Ввод:** 

```go
package main

import (
	"fmt"
	"piscine"
)

func main() {
	root := &piscine.TreeNode{Data: "4"}
	piscine.BTreeInsertData(root, "1")
	piscine.BTreeInsertData(root, "7")
	piscine.BTreeInsertData(root, "5")
	fmt.Println(root.Left.Data)
	fmt.Println(root.Data)
	fmt.Println(root.Right.Left.Data)
	fmt.Println(root.Right.Data)

}
```

- **Вывод:** 

```go
$ go run .
1
4
5
7
$
```

---

## Решение

```go
package piscine

type TreeNode struct {
	Left, Right, Parent *TreeNode
	Data                 string
}

func BTreeInsertData(root *TreeNode, data string) *TreeNode {
	if root == nil {
		return &TreeNode{Data: data}
	}

	current := root
	for {
		if data < current.Data {
			if current.Left == nil {
				current.Left = &TreeNode{Data: data, Parent: current}
				break
			}
			current = current.Left
		} else {
			if current.Right == nil {
				current.Right = &TreeNode{Data: data, Parent: current}
				break
			}
			current = current.Right
		}
	}

	return root
}
```

---

# Разбор задания: BTreeInsertData — вставка данных в бинарное дерево поиска

## Ключевые понятия

| **Инструмент / элемент кода**                  | **Объяснение и назначение**                                                                               |
| ---------------------------------------------- | --------------------------------------------------------------------------------------------------------- |
| **Пакет (`package piscine`)**                  | Объединяет файл в пакет. Пакет — это набор связанных функций, который можно использовать в других файлах. |
| **Структура (`type TreeNode struct { ... }`)** | Описание того, как выглядит один узел дерева: какие у него поля, ссылки, данные.                          |
| **Указатель (`*TreeNode`)**                    | Тип, который хранит адрес узла, а не сам узел. Используется, чтобы менять существующие элементы дерева.   |
| **Корень дерева (`root`)**                     | Самый верхний элемент в дереве. От него всё начинается.                                                   |
| **Сравнение строк (`data < current.Data`)**    | Определяет, идти влево или вправо по дереву.                                                              |
| **Цикл `for { ... }`**                         | Бесконечный цикл, который продолжается, пока мы не вставим новый узел. Выход через `break`.               |
| **`Parent`, `Left`, `Right`**                  | Ссылки на родителя, левого и правого ребёнка — создают структуру дерева.                                  |

---

## Логика и пошаговый разбор кода

---

## 1. Объявление функции

```go
func BTreeInsertData(root *TreeNode, data string) *TreeNode {
```

Эта строка определяет функцию **BTreeInsertData**, которая:

* принимает:

  * `root *TreeNode` — указатель на корень дерева
  * `data string` — значение, которое нужно вставить

* возвращает:

  * `*TreeNode` — корень дерева (всегда!)

Функция **всегда возвращает корень**, даже если дерево меняется внутри.

---

## 2. Проверка: что если дерева ещё нет?

```go
if root == nil {
	return &TreeNode{Data: data}
}
```

**Объяснение:**

* Если `root == nil`, значит дерево пустое.
* То есть вставляемый элемент — это и есть первый узел.
* Создаём новый `TreeNode` и возвращаем его как корень.

**Пример:**

До:

```
root = nil
```

После вставки `"4"`:

```
   "4"
  /   \
nil  nil
```

---

## 3. Настройка начального узла для поиска

```go
current := root
```

**Объяснение:**

* Мы начинаем поиск места вставки с корня.
* `current` — переменная, по которой мы будем “спускаться” вниз по дереву.

---

## 4. Запуск цикла, который ищет позицию для вставки

```go
for {
```

Это бесконечный цикл.
Мы из него выйдем только через `break`, когда найдём подходящее место.

---

## 5. Проверяем: вставлять влево или вправо?

```go
if data < current.Data {
    ...
} else {
    ...
}
```

**Логика бинарного дерева поиска (BST):**

* Если `data` **меньше**, чем значение текущего узла (current.Data) — идём влево.
* Если `data` **больше или равно** — идём вправо.

**Пример:**
Корень = `"4"`
Вставляем `"1"`

→ `"1" < "4"` → идём влево.

---

## 6. Вставка в левое поддерево

```go
if current.Left == nil {
	current.Left = &TreeNode{Data: data, Parent: current}
	break
}
current = current.Left
```

### Объяснение:

* Если левого ребёнка **нет**, то это идеальное место — вставляем новый узел.
* Добавляем `Parent: current`, чтобы сохранить связь вверх.
* `break` завершает цикл — вставка закончена.

Если левый ребёнок **есть**, то:

* спускаемся глубже: `current = current.Left`
* продолжаем цикл заново.

---

## 7. Вставка в правое поддерево

Аналогично левой части:

```go
if current.Right == nil {
	current.Right = &TreeNode{Data: data, Parent: current}
	break
}
current = current.Right
```

**Идём вправо, когда**:
`data >= current.Data`

Логика полностью зеркальная.

---

## 8. Возвращаем корень дерева

```go
return root
```

Почему не возвращаем новый узел?

* Потому что вне функции должен остаться доступ именно к **корню дерева**, а не к вставленному элементу.
* Структура дерева может быть глубокой, но корень — точка входа в неё.

---

# Глоссарий

| **Термин**                             | **Понятное объяснение**                                               |
| -------------------------------------- | --------------------------------------------------------------------- |
| **Binary Search Tree (BST)**           | Дерево, где левый ребёнок всегда меньше, правый — больше.             |
| **Указатель (`*`)**                    | Ссылка на объект, а не его копия. Позволяет менять дерево “по месту”. |
| **Корень (root)**                      | Верхний узел дерева. Начальная точка поиска.                          |
| **Parent**                             | Ссылка на родительский элемент (узел выше по дереву).                 |
| **Left / Right**                       | Ссылки на детей: левый и правый потомки узла.                         |
| **Цикл `for {}`**                      | Бесконечный цикл, который завершается только через `break`.           |
| **break**                              | Прерывает цикл — используется, когда вставка завершена.               |
| **Лексикографическое сравнение строк** | `"1" < "4"`, `"5" < "7"` сравниваются как буквы: Go умеет это делать. |

---

# Заключение

Что важно запомнить:

1. **BST вставляет элементы по правилу: меньше — налево, больше — направо.**
2. Если дерево пустое, первый элемент становится корнем.
3. Мы “спускаемся” по дереву, пока не найдём свободное место.
4. Каждый новый узел обязательно получает правильный `Parent`.
5. Функция всегда возвращает **корень дерева**, потому что он — точка входа.
6. Такой алгоритм обеспечивает быстрый поиск и структуру данных, которую легко обходить.
