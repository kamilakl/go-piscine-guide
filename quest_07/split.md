# Quest 7.6 Split

## Название файла Go
`split.go`

---
## Условия задания

| **Instruction** | **Перевод** |
|------------------|-------------|
| *Write a function that receives a string and a separator and returns a `slice of strings` that results of splitting the string `s` by the separator `sep`.* | *Напишите функцию, которая получает строку и разделитель и возвращает `срез строк`, который является результатом разбиения строки `s` по разделителю `sep`.* |

---
### Пример
-**ввод** s := "HelloHAhowHAareHAyou?" /таб fmt.Printf("%#v\n", piscine.Split(s, "HA"))
-**вывод** []string{"Hello", "how", "are", "you?"}

---
## Решение

```go
package piscine

// Функция Split делит строку s по разделителю sep
func Split(s, sep string) []string {
	// Если разделитель пустой, возвращаем строку как один элемент среза
	if sep == "" {
		return []string{s}
	}

	var result []string  // Срез для хранения частей строки
	var currentString string  // Строка для текущей части

	// Проходим по всем символам строки
	for i := 0; i < len(s); i++ {
		// Если нашли начало разделителя, добавляем текущую часть в результат
		if s[i:i+len(sep)] == sep {
			result = append(result, currentString)  // Добавляем текущую строку в срез
			currentString = ""  // Очищаем текущую строку
			i += len(sep) - 1  // Пропускаем разделитель
		} else {
			// Если это не разделитель, продолжаем собирать текущую строку
			currentString += string(s[i])
		}
	}

	// Добавляем последнюю часть строки после последнего разделителя
	result = append(result, currentString)

	return result
}
```

---

## Ключевые понятия

| **Термин / инструмент** | **Объяснение** |
|--------------------------|----------------------------------|
| **Срез (`[]string`)** | Динамический массив, который может менять длину. В отличие от массива не фиксирован по размеру. Используется для хранения частей строки. Подробнее: https://metanit.com/go/tutorial/2.4.php |
| **Операция `append(slice, value)`** | Добавляет элемент в конец среза. Если места недостаточно создает новый массив, копирует данные и возвращает новый срез. |
| **Строки в Go (`string`)** | Набор байтов (UTF-8). Индексация строк `s[i]` работает по байтам, не по символам. Для ASCII ок, но для Unicode будьте осторожны. |
| **`len(s)`** | Возвращает количество байтов, а не символов. В ASCII это равны величины, но в Unicode нет. |
| **Конкатенация строк (`+=`)** | Операция `currentString += string(s[i])` создаёт новую строку. |
| **Срез подстроки (`s[i:j]`)** | В Go можно брать подстроку по диапазону байтов. Важно: диапазон должен быть корректным и не выходить за границы. |

---

## Логика и пошаговый разбор кода

### 1. Начало кода и его исходные данные

```go
package piscine

func Split(s, sep string) []string {
	if sep == "" {
		return []string{s}
	}

```
- Функция принимает 2 строки и выводит срез строк.
- Если разделитель пустая строка, просто выводим s переведя ее в срез без разделителя.

---

### 2. Создание среза

```go
    var result []string
    var currentString string
```
- Создаем две пустые переменные: срез и строку.
---

### 3. Заполняем срез числами по порядку

```go
    for i := 0; i < len(s); i++ {
		if s[i:i+len(sep)] == sep {
			result = append(result, currentString)  
			currentString = ""  
			i += len(sep) - 1  
	}
```
- Цикл проходит по всей длине строки по байтам.
- Индекс `i` увеличивается: 0, 1, 2, 3...
- Если в разрезе между индексом и 2 строке схожие с тем что указоно в `sep` то массиву добавляем то что сохранили до него убирая то что схож с *`sep`string* 
---
### 4. Выходим из цикла и возвращаем результат

```go
  	result = append(result, currentString)

    return result
```
- Добавляем последнии часть через append и выводим то что у нас получилось
---

## Заключение

Функция `Split` показывает, как работать со срезами и когда использовать `append`.  
Ты создашь свой срез, а затем заполняешь его так чтобы одна строка была разделено по очереди и правильно по задаче.  
Это задание помогает понять:  
- как создаются динамические массивы,  
- как работает функция `append()`,  
- зачем иногда нужны переменные ввиде var,
- как взаимодействовать элементами в строке и менять их как нам надо,
- почему важно написать код динамичным и понятным.
