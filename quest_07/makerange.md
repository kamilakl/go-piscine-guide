## Условия задания

| **Instruction** | **Перевод** |
|------------------|-------------|
| *Write a function that takes an int `min` and an int `max` as parameters. The function must return a slice of ints with all the values between `min` and `max`. `Min` is included, and `max` is excluded. If `min` is greater than or equal to `max`, a `nil` slice is returned. `append` is not allowed for this exercise.* | *Напишите функцию, которая принимает два целых числа `min` и `max` в качестве параметров. Функция должна вернуть срез целых чисел, содержащий все значения от `min` включительно до `max` исключительно. Если `min` больше или равен `max`, функция должна вернуть пустой срез (`nil`). Использование `append` запрещено.* |

---

## Решение

```go
package piscine

func MakeRange(min, max int) []int {
	if min >= max {
		return nil
	}

	size := max - min
	result := make([]int, size)

	for i := 0; i < size; i++ {
		result[i] = min + i
	}

	return result
}
```

---

## Ключевые понятия

| **Термин / инструмент** | **Объяснение** |
|--------------------------|----------------|
| **Срез (`[]int`)** | Структура данных в Go, динамический массив натуральных чисел. В задании нужно создать его вручную через `make`, так как `append` запрещён. |
| **`make([]int, size)`** | Создаёт срез заранее нужной длины. Это позволяет обойтись без `append`. |
| **Пустой срез (`nil`)** | Специальное значение, означающее отсутствие данных. Возвращается, если диапазон некорректный (`min >= max`). |

---

## Логика и пошаговый разбор кода

### 1. Проверка корректности диапазона

```go
package piscine

func MakeRange(min, max int) []int {
    if min >= max {
	    return nil
    }
```
- Если `min` больше или равен `max`, диапазон неправильный.  
- В этом случае нет смысла создавать срез и функция сразу возвращает `nil`.

---

### 2. Вычисляем размер будущего среза

```go
    size := max - min
```
- `size` — количество элементов, которые должны попасть в итоговый диапазон.
- Пример: `min = 3`, `max = 7` → числа: 3, 4, 5, 6 → 4 элемента → `size = 4`.

---

### 3. Создаём срез нужной длины

```go
    result := make([]int, size)
```
- Используем `make`, потому что `append` запрещён.
- Создаём срез правильного размера, чтобы в него можно было записывать элементы по индексу.

---

### 4. Заполняем срез числами по порядку

```go
    for i := 0; i < size; i++ {
	    result[i] = min + i
    }
```
- Цикл заполняет массив по одному элементу.
- Индекс `i` увеличивается: 0, 1, 2, 3...
- Элемент вычисляется как `min + i`:
  - если `min = 3`, получаем: `3, 4, 5, 6`.

---
### 5. Выходим из цикла и возвращаем результат

```go
    return result
```
---

## Заключение

Функция `MakeRange` показывает, как вручную работать со срезами, когда нельзя использовать `append`.  
Ты сам определяешь размер, создаёшь срез через `make`, а затем заполняешь его по индексам.  
Это задание помогает понять:  
- как создаются динамические массивы,  
- как работает диапазон `min..max`,  
- зачем иногда нужны `nil`-возвраты,  
- почему важно заранее планировать размер структуры данных.

