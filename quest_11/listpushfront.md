# Quest 11.2. List Push Front

## Название файла Go
`listpushfront.go`

---

## Условия задания 

| **Instruction** | **Перевод** |
|---------------------------|--------------|
| *Write a function ListPushFront that inserts a new element NodeL at the beginning of the list l while using the structure List.* | *Напишите функцию ListPushFront, которая добавляет новый элемент NodeL в начало списка l, используя структуру List.* |

---

Нужно написать функцию, которая добавляет новый узел `NodeL` **в начало односвязного списка** `l`, используя структуру `List` с указателями на голову (`Head`) и хвост (`Tail`). Функция должна корректно обрабатывать как **пустой**, так и **непустой** список.


### Пример

- **Ввод:** `"Hello"`, `"man"`, `"how are you"` добавляем последовательно в пустой список через `ListPushFront`
- **Вывод:** `how are you man Hello`

---

## Решение

```go
package piscine

type NodeL struct {
	Data interface{}
	Next *NodeL
}

type List struct {
	Head *NodeL
	Tail *NodeL
}

func ListPushFront(l *List, data interface{}) {
	newNode := &NodeL{Data: data}

	if l.Head == nil {
		// Список пуст, новый узел становится головой и хвостом
		l.Head = newNode
		l.Tail = newNode
	} else {
		// Новый узел указывает на текущую голову
		newNode.Next = l.Head
		// Обновляем голову на новый узел
		l.Head = newNode
	}
}
```

---

## Ключевые понятия

| **Термин / элемент кода** | **Объяснение и назначение** |
|----------------------------|-----------------------------|
| **Список (List)** | Односвязный список с указателями на Head и Tail. |
| **Узел (Node / NodeL)** | Элемент списка с данными (`Data`) и ссылкой на следующий узел (`Next`). |
| **Head (голова списка)** | Первый элемент списка. С него начинается обход всех узлов. |
| **Tail (хвост списка)** | Последний элемент списка. Обновляется только при добавлении первого элемента. |
| **Next** | Ссылка на следующий элемент узла. |
| **Data** | Данные, хранящиеся в узле. |
| **Указатель (`*`) / Pointer** | Переменная, которая хранит **адрес** другого значения. Используется для того, чтобы функция могла изменять структуру списка напрямую, а не её копию. |
| **nil** | Нулевое значение указателя в Go. Означает, что ссылка никуда не указывает. |
| **Интерфейс (`interface{}`)** | Универсальный тип данных в Go, который может хранить значение любого типа. |
| **Метод добавления (push front)** | Операция, добавляющая элемент в начало списка. |
| **Операция O(1)** | Означает, что операция выполняется за постоянное время, независимо от длины списка. |
| **Пакет (`package ...`)** | Определяет пакет, к которому принадлежит код. |

### Полезные ссылки для изучения
- RU [Хабр: Что такое связный список и как он работает](https://habr.com/ru/articles/441574/)  
- EN [GeeksforGeeks: Linked List Data Structure Explained](https://www.geeksforgeeks.org/data-structures/linked-list/)

---

## Логика и пошаговый разбор кода

### 1. Объявление функции

#### В коде:

```go
func ListPushFront(l *List, data interface{}) {
```

#### Объяснение:

Эта строка объявляет функцию **ListPushFront**, которая принимает:

- Функция `ListPushFront` принимает два параметра:
    - `l` — указатель на структуру `List`, чтобы изменения отражались на исходном списке.
    - `data` — данные нового узла, который нужно добавить в начало списка.
- Функция ничего не возвращает — она изменяет список напрямую через указатель `l`.


### 2. Создание нового узла

#### В коде:

```go
newNode := &NodeL{Data: data}
```

#### Объяснение:

- Создаётся новый узел `NodeL`.
- Поле `Data` получает значение `data`.
- Поле `Next` по умолчанию равно `nil`.
- Использование `&` создаёт указатель на новый узел, который можно связывать с существующим списком.

#### Пример:

- Если `data == "Hello"`, то `newNode` → `[Hello | nil]`.

### 3. Проверка пустого списка

#### В коде:

```go
if l.Head == nil {
    l.Head = newNode
    l.Tail = newNode
}
```

#### Объяснение:

- Условие `l.Head == nil` проверяет, пуст ли список (нет ни одного узла).
- Если список пуст:
    - `newNode` становится головой списка (`Head`).
    - Поскольку это единственный элемент, он же становится хвостом списка (`Tail`).
- Этот шаг предотвращает ошибки при последующих добавлениях.

#### Пример:

- Пустой список `nil` → после добавления `"Hello"`: `Head` → `[Hello]`, `Tail` → `[Hello]`.

### 4. Добавление в начало непустого списка

#### В коде:

```go
newNode.Next = l.Head
l.Head = newNode
```

#### Объяснение:

- `newNode.Next = l.Head` — новый узел теперь указывает на текущую голову списка.
- `l.Head = newNode` — обновляем голову списка на новый узел.
- Хвост (`Tail`) остаётся прежним, так как добавление происходит в начало.

#### Пример:

- Список до добавления: `[Hello]` → `Head` = `[Hello]`, `Tail` = `[Hello]`
- После `ListPushFront(l, "man")`: `[man] -> [Hello]` → `Head` = `[man]`, `Tail` = `[Hello]`
- После `ListPushFront(l, "how are you")`: `[how are you] -> [man] -> [Hello]` → `Head` = `[how are you]`, `Tail` = `[Hello]`

### 5. Итоговое поведение

- Функция корректно обрабатывает оба случая: пустой список и непустой.
- Новый элемент становится головой, старые элементы сдвигаются дальше.
- Все изменения происходят через указатели — исходный список модифицируется «на месте».
- Операция добавления в начало выполняется за **O(1)**, без прохода по всему списку.

### Пример полного прохождения (пошагово)

1. Список пуст (`Head == nil`, `Tail == nil`). Вызываем `ListPushFront(l, "Hello")`.
Результат: `Head -> [Hello]`, `Tail -> [Hello]`.
2. Вызываем `ListPushFront(l, "man")`.
До: `Head -> [Hello]`, `Tail -> [Hello]`
Выполняем: `newNode.Next = l.Head` и `l.Head = newNode`.
Результат: `Head -> [man] -> [Hello]`, `Tail -> [Hello]`.
3. Вызываем `ListPushFront(l, "how are you")`.
До: `Head -> [man] -> [Hello]`, `Tail -> [Hello]`
Выполняем: `newNode.Next = l.Head` и `l.Head = newNode`.
Результат: `Head -> [how are you] -> [man] -> [Hello]`, `Tail -> [Hello]`.

---

## Заключение

- Функция `ListPushFront` добавляет новый элемент в начало односвязного списка.
- При первом добавлении узел становится и головой, и хвостом списка.
- При последующих добавлениях новый узел становится головой, а хвост остаётся прежним.
- Все изменения происходят через указатели, поэтому список модифицируется напрямую, без копирования.
- Добавление в начало списка выполняется за **O(1)** — операция выполняется за постоянное время.
- Этот приём используется в реализации очередей, стэков и других структур данных, где важно быстрое добавление элементов в начало списка.
- Важно правильно инициализировать `Head` и `Tail`, чтобы избежать ошибок при дальнейших операциях со списком.
