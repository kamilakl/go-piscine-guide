# Quest 11.13 - ListSort

## Название файла Go
`listsort.go`

---

## Условия задания 

| **Instruction (eng)**                                                                 | **Перевод (ru)**                                                                    |
| ------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------- |
| Write a function `ListSort` that sorts the nodes of a linked list by ascending order. | Написать функцию `ListSort`, которая сортирует узлы связного списка по возрастанию. |


---

Нужно написать функцию, которая принимает голову односвязного списка целых чисел и возвращает отсортированный по возрастанию список.

### Пример

Исходный список:

```go
5 -> 4 -> 3 -> 2 -> 1 -> nil
```

После сортировки:

```go
1 -> 2 -> 3 -> 4 -> 5 -> nil
```

---

## Решение

```go
package piscine

type NodeI struct {
	Data int
	Next *NodeI
}

func ListSort(l *NodeI) *NodeI {
	if l == nil || l.Next == nil {
		return l
	}

	swapped := true
	for swapped {
		swapped = false
		current := l
		for current.Next != nil {
			if current.Data > current.Next.Data {
				current.Data, current.Next.Data = current.Next.Data, current.Data
				swapped = true
			}
			current = current.Next
		}
	}

	return l

```

---

## Ключевые понятия

| **Термин / элемент кода**            | **Объяснение**                                                                   |
| ------------------------------------ | -------------------------------------------------------------------------------- |
| **Список (List)** | Структура данных, состоящая из последовательности элементов (узлов), каждый из которых содержит данные и ссылку на следующий элемент. |
| **Узел (Node / NodeL)** | Элемент списка, который хранит данные (`Data`) и указатель на следующий узел (`Next`). |
| **Head (голова списка)** | Первый элемент списка. С него начинается обход всех узлов. |
| **Tail (хвост списка)** | Последний элемент списка. Его поле `Next` всегда `nil`. |
| **Next** | Ссылка на следующий элемент узла. |
| **Data** | Данные, хранящиеся в узле. |
| **Указатель (`*`) / Pointer** | Переменная, которая хранит **адрес** другого значения. Используется для того, чтобы функция могла изменять структуру списка напрямую, а не её копию. |
| **Итерация по списку** | Движение по узлам через `Next`.                         |
| **Интерфейс (`interface{}`)** | Универсальный тип данных в Go, который может хранить значение любого типа. |
| **Структура (`struct`)** | Пользовательский тип, объединяющий несколько полей в одну сущность. В данном случае `List` и `NodeL`. |
| **Пакет (`package ...`)** | Определяет пакет, к которому принадлежит код. |
| **Swapped**     | Булева переменная, которая показывает, были ли изменения в текущей итерации.                               |
| **Bubble Sort** | Алгоритм сортировки, который проходит по списку и меняет местами соседние элементы, если они не в порядке. |
| **O(n²)**       | Временная сложность алгоритма сортировки пузырьком в худшем случае.                                        |
| **nil**         | Конец списка.                                                                                              |

---

## Логика и пошаговый разбор кода

### 1. Объявление функции

```go
func ListSort(l *NodeI) *NodeI {
```
Эта строка объявляет функцию **ListSort**, которая принимает:
Функция `ListSort` принимает:
- `l *NodeI` — указатель на голову списка
- Возвращает новую голову отсортированного списка


### 2. Проверка списка на пустоту или один элемент

```go
if l == nil || l.Next == nil {
    return l
}
```

Если список пуст или содержит один узел — он уже отсортирован.

### 3. Основной цикл сортировки

```go
swapped := true
for swapped {
    swapped = false
    current := l
    for current.Next != nil {
        if current.Data > current.Next.Data {
            current.Data, current.Next.Data = current.Next.Data, current.Data
            swapped = true
        }
        current = current.Next
    }
}
```

- `swapped` показывает, поменялись ли элементы на текущей итерации.
- Пока есть перестановки → продолжаем проход по списку.
- Сравниваем соседние элементы `current.Data` и `current.Next.Data`.
- Если `current.Data > current.Next.Data`, меняем местами значения.
- Двигаемся по списку с помощью `current = current.Next`.
- Это реализация сортировки пузырьком, адаптированная для связного списка.

### 4. Возврат отсортированного списка

```go
return l
```

После завершения всех итераций `l` указывает на голову отсортированного списка.

### Пошаговый пример

Исходный список:

```go
5 → 4 → 3 → 2 → 1 → nil
```

| Итерация | Состояние списка  |
| -------- | ----------------- |
| 1        | 4 → 3 → 2 → 1 → 5 |
| 2        | 3 → 2 → 1 → 4 → 5 |
| 3        | 2 → 1 → 3 → 4 → 5 |
| 4        | 1 → 2 → 3 → 4 → 5 |

Итог:

```go
1 → 2 → 3 → 4 → 5 → nil
```

---

## Заключение

- `ListSort` использует сортировку пузырьком, изменяя данные в узлах на месте, без создания новых узлов.
- Сложность алгоритма **O(n²)**.
- Важные моменты: корректно проверять пустой список, правильно обновлять указатель `current`.
- Этот подход работает только с целыми числами, для других типов понадобится адаптация сравнения.
