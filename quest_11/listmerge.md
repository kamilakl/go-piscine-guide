# Quest 11.12 - ListMerge

## Название файла Go
listmerge.go

---

## Условия задания 

| **Instruction (eng)**                                                                   | **Перевод (ru)**                                                                          |
| --------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- |
| Write a function `ListMerge` that places elements of list `l2` at the end of list `l1`. | Написать функцию `ListMerge`, которая переносит элементы списка `l2` в конец списка `l1`. |
| New elements should not be created!                                                     | Новые элементы **не должны создаваться**!                                                 |

---

Нужно написать функцию, которая соединяет два связанных списка, добавляя второй список в конец первого.

### Пример

- **Ввод:** *(input)*
- **Вывод:** *(output)*

---

## Решение

```go
package piscine

func ListMerge(l1 *List, l2 *List) {
    if l2.Head == nil {
        return
    }

    if l1.Head == nil {
        l1.Head = l2.Head
        l1.Tail = l2.Tail
    } else {
        l1.Tail.Next = l2.Head
        l1.Tail = l2.Tail
    }

    l2.Head = nil
    l2.Tail = nil
}
```

---

## Ключевые понятия

| **Термин / элемент кода**            | **Объяснение**                                                                   |
| ------------------------------------ | -------------------------------------------------------------------------------- |
| **Список (List)** | Структура данных, состоящая из последовательности элементов (узлов), каждый из которых содержит данные и ссылку на следующий элемент. |
| **Узел (Node / NodeL)** | Элемент списка, который хранит данные (`Data`) и указатель на следующий узел (`Next`). |
| **Head (голова списка)** | Первый элемент списка. С него начинается обход всех узлов. |
| **Tail (хвост списка)** | Последний элемент списка. Его поле `Next` всегда `nil`. |
| **Next** | Ссылка на следующий элемент узла. |
| **Data** | Данные, хранящиеся в узле. |
| **Указатель (`*`) / Pointer** | Переменная, которая хранит **адрес** другого значения. Используется для того, чтобы функция могла изменять структуру списка напрямую, а не её копию. |
| **Интерфейс (`interface{}`)** | Универсальный тип данных в Go, который может хранить значение любого типа. |
| **Структура (`struct`)** | Пользовательский тип, объединяющий несколько полей в одну сущность. В данном случае `List` и `NodeL`. |
| **Пакет (`package ...`)** | Определяет пакет, к которому принадлежит код. |
| **Слияние списков**           | Процесс, при котором элементы одного списка добавляются в конец другого **без создания новых узлов**. |
| **Операция O(1)** | Означает, что операция выполняется за постоянное время, независимо от длины списка. |

---

## Логика и пошаговый разбор кода

### 1. Объявление функции

```go
func ListMerge(l1 *List, l2 *List) {
```
Эта строка объявляет функцию **ListMerge**, которая принимает:
- `l1 *List` — основной список, в конец которого будут добавлены элементы
- `l2 *List` — второй список, узлы которого будут перенесены в `l1`
Оба параметра — указатели, чтобы изменения отражались на исходных списках.

### 2. Проверяем: пустой ли второй список

```go
if l2.Head == nil {
    return
}
```

Если `l2` **пуст** → ничего добавлять, функция заканчивается.

### 3. Проверяем: пуст ли первый список

```go
if l1.Head == nil {
    l1.Head = l2.Head
    l1.Tail = l2.Tail
```

Если `l1` **пуст** → он просто становится `l2`.
Все элементы `l2` теперь — это `l1`.

### 4. Сцепляем списки, если оба не пустые

```go
l1.Tail.Next = l2.Head
l1.Tail = l2.Tail
```

- `l1.Tail.Next` теперь указывает на начало `l2`
- `l1.Tail` становится хвостом `l2`

### 5. Очищаем второй список

```go
l2.Head = nil
l2.Tail = nil
```

Так как узлы уже в `l1`, `l2` должен стать пустым.

### Пошаговый пример

У нас два списка:

```go
l1: a → b → c → d → nil
l2: e → f → g → h → nil
```

#### Шаг 1 — проверка l2

`l2` не пуст → продолжаем.

#### Шаг 2 — l1 не пуст → выполняем слияние

Соединяем хвост `l1` с головой `l2`:

`d.Next = e`

Обновляем хвост `l1`:

`l1.Tail = h`

#### Результат:

```go
a → b → c → d → e → f → g → h → nil
```

`l2` после объединения:

```go
nil
```

---

## Заключение

В этом задании важно понять:
- как работают указатели в структурах,
- как объединить два списка без копирования узлов,
- что `Tail` нужно обязательно обновлять,
- что список `l2` после слияния должен стать пустым,
- что время работы — **O(1)**, если списки не пустые (работа идёт только с хвостами).
