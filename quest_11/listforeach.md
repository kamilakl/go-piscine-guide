# Quest 11.8 - Task Title

## Название файла Go
`listforeach.go`

---

## Условия задания 

| **Instruction**                                                                                                          | **Перевод**                                                                                          |
| ------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------- |
| *Write a function `ListForEach` that applies a function given as argument to the data within each node of the list `l`.* | *Напишите функцию `ListForEach`, которая применяет переданную функцию ко всем элементам списка `l`.* |
| *The function given as argument must have a pointer as argument: `f(*NodeL)`.*                                           | *Передаваемая функция должна принимать указатель на узел (`*NodeL`).*                                |

После выполнения `ListForEach(l, f)`:
- каждый узел списка должен быть изменён функцией `f(node)`
- порядок списка не меняется
- изменяются только данные внутри узлов (`Data`)

---

Нужно написать функцию, которая *(...)*.

### Пример

#### Ввод

```go
link := &piscine.List{}

piscine.ListPushBack(link, "1")
piscine.ListPushBack(link, "2")
piscine.ListPushBack(link, "3")
piscine.ListPushBack(link, "5")

piscine.ListForEach(link, piscine.Add2_node)
```

#### Вывод

```go
12
22
32
52
```

---

## Решение

```go
package piscine

func ListForEach(l *List, f func(*NodeL)) {
	current := l.Head
	for current != nil {
		f(current)
		current = current.Next
	}
}

func Add2_node(node *NodeL) {
	switch node.Data.(type) {
	case int:
		node.Data = node.Data.(int) + 2
	case string:
		node.Data = node.Data.(string) + "2"
	}
}

func Subtract3_node(node *NodeL) {
	switch node.Data.(type) {
	case int:
		node.Data = node.Data.(int) - 3
	case string:
		node.Data = node.Data.(string) + "-3"
	}
}
```

---

## Ключевые понятия

| **Термин / элемент кода**            | **Объяснение**                                                                   |
| ------------------------------------ | -------------------------------------------------------------------------------- |
| **Список (List)** | Структура данных, состоящая из последовательности элементов (узлов), каждый из которых содержит данные и ссылку на следующий элемент. |
| **Узел (Node / NodeL)** | Элемент списка, который хранит данные (`Data`) и указатель на следующий узел (`Next`). |
| **Head (голова списка)** | Первый элемент списка. С него начинается обход всех узлов. |
| **Tail (хвост списка)** | Последний элемент списка. Его поле `Next` всегда `nil`. |
| **Next** | Ссылка на следующий элемент узла. |
| **Data** | Данные, хранящиеся в узле. |
| **Указатель (`*`) / Pointer** | Переменная, которая хранит **адрес** другого значения. Используется для того, чтобы функция могла изменять структуру списка напрямую, а не её копию. |
| **Type assertion**     | Проверка и преобразование типа (`.(int)`, `.(string)`). |
| **f func(*NodeL)**     | Передаваемая функция, выполняющая операцию над узлом.   |
| **Итерация по списку** | Движение по узлам через `Next`.                         |
| **Интерфейс (`interface{}`)** | Универсальный тип данных в Go, который может хранить значение любого типа. |
| **Структура (`struct`)** | Пользовательский тип, объединяющий несколько полей в одну сущность. В данном случае `List` и `NodeL`. |
| **Пакет (`package ...`)** | Определяет пакет, к которому принадлежит код. |
| **O(n)**               | Временная сложность — один проход по списку.            |

---

## Логика и пошаговый разбор кода

### 1. Объявление функции

```go
func ListForEach(l *List, f func(*NodeL)) {
```

Эта строка объявляет функцию **ListForEach**, которая принимает:

Функция принимает:
- `l *Lis`t — указатель на список
- `f func(*NodeL)` — функция обработки узла
Указатель **важен**, потому что мы изменяем данные прямо в существующих узлах.


### 2. Начинаем обход списка

```go
current := l.Head
```

Если список пуст → цикл не выполнится.

### 3. Основной цикл

```go
for current != nil {
    f(current)
    current = current.Next
}
```

Пошагово:
1. Выполняется функция над текущим узлом `f(current)`
2. Переходим к следующему узлу `current = current.Next`

### 4. Пошаговый пример

#### Исходные данные:

`"1" → "2" → "3" → "5" → nil`

#### Вызов:

`ListForEach(link, Add2_node)`

#### Итерация 1

`"1"` → `"12"`

#### Итерация 2

`"2"` → `"22"`

#### Итерация 3

`"3"` → `"32"`

#### Итерация 4

`"5"` → `"52"`

```go
12 → 22 → 32 → 52 → nil
```

---

## Заключение

- `ListForEach` позволяет применять функцию к каждому элементу списка.
- Порядок узлов не меняется, меняются только данные (`Data`).
- Функция гибкая: можно передавать разные обработчики (`Add2_node`, `Subtract3_node` и т.д.).
- Работает за **O(n)** и не требует создания новых узлов.
- Очень полезна для преобразования данных в списке.
