# Quest 11.1. List Push Back

## Название файла Go
`listpushback.go`

---

## Условия задания 

| **Instruction** | **Перевод** |
|---------------------------|--------------|
| *Write a function `ListPushBack` that inserts a new element `NodeL` at the end of the list `l` while using the structure `List`.* | *Напишите функцию `ListPushBack`, которая добавляет новый элемент `NodeL` в конец списка `l`, используя структуру `List`.* |


---

Нужно написать функцию, которая добавляет новый узел в конец односвязного списка, используя структуру `List` с указателями на голову и хвост.

### Пример

- **Ввод:** `"Hello"`, `"man"`, `"how are you"` добавляем последовательно в пустой список 
- **Вывод:** 
```
	Hello
	man
	how are you
```

---

## Решение

```go
package piscine

type NodeL struct {
	Data interface{}
	Next *NodeL
}

type List struct {
	Head *NodeL
	Tail *NodeL
}

func ListPushBack(l *List, data interface{}) {
	newNode := &NodeL{Data: data}

	if l.Head == nil {
		l.Head = newNode
		l.Tail = newNode
	} else {
		l.Tail.Next = newNode
		l.Tail = newNode
	}
}
```

---

## Ключевые понятия

| **Инструмент / элемент кода** | **Объяснение и назначение** |
|-------------------------------|------------------------------|
| **Пакет (`package ...`)** | Определяет пакет, к которому принадлежит код. |
| **Структура (`struct`)** | Определяет пользовательский тип с полями (например, `NodeL`, `List`). |
| **NodeL** | Узел списка с полями `Data` и `Next`. |
| **List** | Структура с указателями на голову (`Head`) и хвост (`Tail`). |
| **interface{}** | Универсальный тип для хранения данных любого типа. |
| **nil** | Пустой указатель, означает отсутствие ссылки на следующий элемент. |
| **Указатель (*)** | Позволяет работать с данными по ссылке, а не копировать их. |
| **Head** | Указатель на первый элемент списка. |
| **Tail** | Указатель на последний элемент списка. |
| **Next** | Ссылка на следующий элемент узла. |
| **Data** | Данные, хранящиеся в узле. |
| **Односвязный список** | Структура, где каждый элемент знает только о следующем. |


---

## Логика и пошаговый разбор кода

### 1. Объявление функции

#### В коде:

```go
func ListPushBack(l *List, data interface{}) {
```
Эта строка объявляет функцию  **ListPushBack**, которая принимает два параметра:
- `l` — указатель на структуру `List (*List)`, представляющую односвязный список;
- `data` — значение типа `interface{}`, которое нужно поместить в новый узел списка.
Функция ничего не возвращает — она модифицирует переданный список по ссылке.

### 2. Создание нового узла

#### В коде:

```go
newNode := &NodeL{Data: data}
```

#### Объяснение:

- Создаётся новый экземпляр `NodeL`, в поле `Data` которого записывается переданное `data`.
- `Next` по умолчанию равен `nil` (то есть новый узел временно не указывает на следующий).
- Использование `&` даёт указатель на новый узел, который затем будет связан с существующим списком.

#### Пример:
- Если data == "Hello", то newNode — это узел [Hello | nil].

### 3. Проверка пустого списка (инициализация)

#### В коде:

```go
if l.Head == nil {
    l.Head = newNode
    l.Tail = newNode
}
```

#### Объяснение:

- Условие `l.Head == nil` проверяет, пуст ли список (нет ни одного узла).
- Если список пуст:
	- `newNode` становится первым элементом списка — присваивается `Head`.
	- Поскольку это единственный элемент, он же и `Tail` (хвост).
- Это важный шаг: корректная инициализация `Head` и `Tail` предотвращает ошибки при последующих операциях.

#### Пример:

- Пустой список `nil` → после добавления `"Hello"`: `Head` → `[Hello]`, `Tail` → `[Hello]`.

### 4. Добавление в конец существующего списка

#### В коде:

```go
l.Tail.Next = newNode
l.Tail = newNode
```

#### Объяснение:

- Если список не пуст, у нас уже есть `Tail` — текущий последний узел.
- `l.Tail.Next = newNode` — предыдущий хвост начинает указывать на новый узел, связывая список.
- `l.Tail = newNode` — обновляем указатель `Tail`, теперь новым хвостом является `newNode`.
- Благодаря этому операция добавления выполняется за **O(1)** — без прохода по всему списку.

#### Иллюстрация:

Было: `... -> [A] (Tail)`
После `l.Tail.Next = newNode`: `... -> [A] -> [B]`
После `l.Tail` = newNode: `Tail` указывает на `[B]`.

### 5. Итоговое поведение функции

- Функция корректно обрабатывает оба случая: пустой список и непустой.
- После выполнения `ListPushBack(l, data)` новый элемент оказывается в конце списка.
- Порядок существующих элементов сохраняется.
- Все изменения происходят через указатели — список изменяется «на месте» (по ссылке `l`).

### Пример полного прохождения (пошагово)

1. Список пуст (Head == nil, Tail == nil). Вызываем ListPushBack(l, "Hello").
Результат: Head -> [Hello], Tail -> [Hello].
2. Вызываем ListPushBack(l, "man").
До: Tail -> [Hello]. Выполняем Tail.Next = newNode и Tail = newNode.
Результат: Head -> [Hello] -> [man], Tail -> [man].
3. Вызываем ListPushBack(l, "how are you"). Аналогично добавляется третий узел в конец.

---

## Глоссарий

| **Термин** | **Понятное объяснение** |
|-------------|--------------------------|
| **Список (List)** | Структура данных, состоящая из последовательности элементов (узлов), каждый из которых содержит данные и ссылку на следующий элемент. |
| **Узел (Node)** | Элемент списка, который хранит данные (`Data`) и указатель на следующий узел (`Next`). |
| **Указатель (`*`)** | Ссылка на объект в памяти. Позволяет функции изменять переданные структуры напрямую. |
| **`Head` (голова списка)** | Первый элемент списка. С него начинается обход всех узлов. |
| **`Tail` (хвост списка)** | Последний элемент списка. Его поле `Next` всегда `nil`. |
| **`nil`** | Нулевое значение указателя в Go. Означает, что ссылка никуда не указывает. |
| **Интерфейс (`interface{}`)** | Универсальный тип данных в Go, который может хранить значение любого типа. |
| **Операция `O(1)`** | Означает, что операция выполняется за постоянное время, независимо от длины списка. |
| **Структура (`struct`)** | Пользовательский тип, объединяющий несколько полей в одну сущность. В данном случае `List` и `NodeL`. |
| **Метод добавления (push back)** | Операция, добавляющая элемент в конец списка. |

---

## Заключение

- Функция `ListPushBack` добавляет новый элемент в конец односвязного списка.  
- При первом добавлении инициализируются `Head` и `Tail`.  
- При последующих добавлениях новый узел связывается с предыдущим хвостом и становится новым `Tail`.  
- Вся работа происходит через указатели, поэтому изменения отражаются на исходном объекте списка.  
- Операция добавления в конец выполняется за **O(1)** — максимально эффективно для таких структур.  
- Этот приём используется в реализации очередей, буферов и многих структур данных, где важно быстрое добавление элементов в конец.

