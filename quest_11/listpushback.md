# Quest 11.1. List Push Back

## Название файла Go
`listpushback.go`

---

## Условия задания 

| **Instruction** | **Перевод** |
|---------------------------|--------------|
| *Write a function `ListPushBack` that inserts a new element `NodeL` at the end of the list `l` while using the structure `List`.* | *Напишите функцию `ListPushBack`, которая добавляет новый элемент `NodeL` в конец списка `l`, используя структуру `List`.* |


---

Нужно написать функцию, которая добавляет новый узел в конец односвязного списка, используя структуру `List` с указателями на голову и хвост.

### Пример

- **Ввод:** `"Hello"`, `"man"`, `"how are you"` добавляем последовательно в пустой список 
- **Вывод:** 
```
Hello
man
how are you
```

---

## Решение

```go
package piscine

type NodeL struct {
	Data interface{}
	Next *NodeL
}

type List struct {
	Head *NodeL
	Tail *NodeL
}

func ListPushBack(l *List, data interface{}) {
	newNode := &NodeL{Data: data}

	if l.Head == nil {
		l.Head = newNode
		l.Tail = newNode
	} else {
		l.Tail.Next = newNode
		l.Tail = newNode
	}
}
```

---

## Ключевые понятия

| **Термин / элемент кода** | **Объяснение и назначение** |
|----------------------------|-----------------------------|
| **Список (List)** | Структура данных, состоящая из последовательности элементов (узлов), каждый из которых содержит данные и ссылку на следующий элемент. |
| **Узел (Node / NodeL)** | Элемент списка, который хранит данные (`Data`) и указатель на следующий узел (`Next`). |
| **Head (голова списка)** | Первый элемент списка. С него начинается обход всех узлов. |
| **Tail (хвост списка)** | Последний элемент списка. Его поле `Next` всегда `nil`. |
| **Next** | Ссылка на следующий элемент узла. |
| **Data** | Данные, хранящиеся в узле. |
| **Указатель (`*`) / Pointer** | Переменная, которая хранит **адрес** другого значения. Используется для того, чтобы функция могла изменять структуру списка напрямую, а не её копию. |
| **nil** | Нулевое значение указателя в Go. Означает, что ссылка никуда не указывает. |
| **Интерфейс (`interface{}`)** | Универсальный тип данных в Go, который может хранить значение любого типа. |
| **Структура (`struct`)** | Пользовательский тип, объединяющий несколько полей в одну сущность. В данном случае `List` и `NodeL`. |
| **Метод добавления (push back)** | Операция, добавляющая элемент в конец списка. |
| **Операция O(1)** | Означает, что операция выполняется за постоянное время, независимо от длины списка. |
| **Пакет (`package ...`)** | Определяет пакет, к которому принадлежит код. |

### Полезные ссылки для изучения
- RU [Хабр: Что такое связный список и как он работает](https://habr.com/ru/articles/441574/)  
- EN [GeeksforGeeks: Linked List Data Structure Explained](https://www.geeksforgeeks.org/data-structures/linked-list/)

---

## Логика и пошаговый разбор кода

### 1. Объявление функции

#### В коде:

```go
func ListPushBack(l *List, data interface{}) {
```
Эта строка объявляет функцию  **ListPushBack**, которая принимает два параметра:

- `l` — указатель на структуру `List (*List)`, представляющую односвязный список;
- `data` — значение типа `interface{}`, которое нужно поместить в новый узел списка.
Функция ничего не возвращает — она модифицирует переданный список по ссылке.

### 2. Создание нового узла

#### В коде:

```go
newNode := &NodeL{Data: data}
```

#### Объяснение:

- Создаётся новый экземпляр `NodeL`, в поле `Data` которого записывается переданное `data`.
- `Next` по умолчанию равен `nil` (то есть новый узел временно не указывает на следующий).
- Использование `&` даёт указатель на новый узел, который затем будет связан с существующим списком.

#### Пример:
- Если `data == "Hello"`, то `newNode` — это узел `[Hello | nil]`.

### 3. Проверка пустого списка (инициализация)

#### В коде:

```go
if l.Head == nil {
    l.Head = newNode
    l.Tail = newNode
}
```

#### Объяснение:

- Условие `l.Head == nil` проверяет, пуст ли список (нет ни одного узла).
- Если список пуст:
	- `newNode` становится первым элементом списка — присваивается `Head`.
	- Поскольку это единственный элемент, он же и `Tail` (хвост).
- Это важный шаг: корректная инициализация `Head` и `Tail` предотвращает ошибки при последующих операциях.

#### Пример:

- Пустой список `nil` → после добавления `"Hello"`: `Head` → `[Hello]`, `Tail` → `[Hello]`.

### 4. Добавление в конец существующего списка

#### В коде:

```go
l.Tail.Next = newNode
l.Tail = newNode
```

#### Объяснение:

- Если список не пуст, у нас уже есть `Tail` — текущий последний узел.
- `l.Tail.Next = newNode` — предыдущий хвост начинает указывать на новый узел, связывая список.
- `l.Tail = newNode` — обновляем указатель `Tail`, теперь новым хвостом является `newNode`.
- Благодаря этому операция добавления выполняется за **O(1)** — без прохода по всему списку.

#### Пример:

Было: `... -> [A] (Tail)`
После `l.Tail.Next = newNode`: `... -> [A] -> [B]`
После `l.Tail` = newNode: `Tail` указывает на `[B]`.

### 5. Итоговое поведение функции

- Функция корректно обрабатывает оба случая: пустой список и непустой.
- После выполнения `ListPushBack(l, data)` новый элемент оказывается в конце списка.
- Порядок существующих элементов сохраняется.
- Все изменения происходят через указатели — список изменяется «на месте» (по ссылке `l`).

### Пример полного прохождения (пошагово)

1. Список пуст (`Head == nil`, `Tail == nil`). Вызываем `ListPushBack(l, "Hello")`.
Результат: `Head -> [Hello]`, `Tail -> [Hello]`.
2. Вызываем `ListPushBack(l, "man")`.
До: `Tail -> [Hello]`. Выполняем `Tail.Next = newNode` и `Tail = newNode`.
Результат: `Head -> [Hello] -> [man]`, `Tail -> [man]`.
3. Вызываем `ListPushBack(l, "how are you")`. Аналогично добавляется третий узел в конец.

---

## Заключение

- Функция `ListPushBack` добавляет новый элемент в конец односвязного списка.  
- При первом добавлении инициализируются `Head` и `Tail`.  
- При последующих добавлениях новый узел связывается с предыдущим хвостом и становится новым `Tail`.  
- Вся работа происходит через указатели, поэтому изменения отражаются на исходном объекте списка.  
- Операция добавления в конец выполняется за **O(1)** — максимально эффективно для таких структур.  
- Этот приём используется в реализации очередей, буферов и многих структур данных, где важно быстрое добавление элементов в конец.