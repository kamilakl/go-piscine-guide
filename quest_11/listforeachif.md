# Quest 11.9 - Task Title

## Название файла Go
`listforeachif.go`

---

## Условия задания 

| **Instruction**                                                                               | **Перевод**                                                                                                                 |
| --------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------- |
| Write a function `ListForEachIf` that applies a function to the data of some nodes of the list `l`. | Написать функцию `ListForEachIf`, которая применяет функцию к данным только тех узлов списка `l`, которые удовлетворяют условию. |
| It receives two functions: `f` and `cond`.                                                          | Функция принимает две функции: `f` и `cond`.                                                                                     |
| `f` is applied to the node.                                                                         | `f` применяется к узлу (меняет данные или выводит их).                                                                           |
| `cond` returns a boolean and decides whether `f` should be applied.                                 | `cond` возвращает булево значение и решает — применять ли `f` к текущему узлу.                                                   |


---

Нужно написать функцию, которая проходит по связанному списку и выполняет действие только над теми узлами, которые прошли проверку функцией `cond`.

### Пример

#### Ввод

Исходный список:

```go
1 → "hello" → 3 → "there" → 23 → "!" → 54 → nil
```

Вызовы:

```go
ListForEachIf(link, PrintElem, IsPositiveNode)
ListForEachIf(link, StringToInt, IsAlNode)
```

#### Вывод

```go
1->hello->3->there->23->!->54->nil
--------function applied--------
1
3
23
54
--------function applied--------
1->2->3->2->23->2->54->nil
```

---

## Решение

```go
package piscine

func ListForEachIf(l *List, f func(*NodeL), cond func(*NodeL) bool) {
    current := l.Head
    for current != nil {
        if cond(current) {
            f(current)
        }
        current = current.Next
    }
}
```

---

## Ключевые понятия

## Ключевые понятия

| **Термин / элемент кода**            | **Объяснение**                                                                   |
| ------------------------------------ | -------------------------------------------------------------------------------- |
| **Список (List)** | Структура данных, состоящая из последовательности элементов (узлов), каждый из которых содержит данные и ссылку на следующий элемент. |
| **Узел (Node / NodeL)** | Элемент списка, который хранит данные (`Data`) и указатель на следующий узел (`Next`). |
| **Head (голова списка)** | Первый элемент списка. С него начинается обход всех узлов. |
| **Tail (хвост списка)** | Последний элемент списка. Его поле `Next` всегда `nil`. |
| **Next** | Ссылка на следующий элемент узла. |
| **Data** | Данные, хранящиеся в узле. |
| **Указатель (`*`) / Pointer** | Переменная, которая хранит **адрес** другого значения. Используется для того, чтобы функция могла изменять структуру списка напрямую, а не её копию. |
| **Type assertion**     | Проверка и преобразование типа (`.(int)`, `.(string)`). |
| **f func(*NodeL)**     | Передаваемая функция, выполняющая операцию над узлом.   |
| **Итерация по списку** | Движение по узлам через `Next`.                         |
| **Условие (`cond`)**                              | Функция, которая определяет, подходит ли узел для обработки.                             |
| **Интерфейс (`interface{}`)** | Универсальный тип данных в Go, который может хранить значение любого типа. |
| **Структура (`struct`)** | Пользовательский тип, объединяющий несколько полей в одну сущность. В данном случае `List` и `NodeL`. |
| **Пакет (`package ...`)** | Определяет пакет, к которому принадлежит код. |
| **O(n)**               | Временная сложность — один проход по списку.            |

---

## Логика и пошаговый разбор кода

### 1. Объявление функции

```go
func ListForEachIf(l *List, f func(*NodeL), cond func(*NodeL) bool) {
```
Эта строка объявляет функцию **ListForEachIf**, которая принимает:

Функция принимает:
- `l` — список
- `f` — действие, которое выполняем над подходящими узлами
- `cond` — проверка, применяется ли действие к узлу
Указатель **важен**, потому что мы изменяем данные прямо в существующих узлах.


### 2. Начало обхода списка

```go
current := l.Head
```

Начинаем с первого узла.

### 3. Цикл обхода

```go
for current != nil {
```

Идём по списку, пока не дойдём до `nil`.

### 4. Проверка условия

```go
if cond(current) {
```

Если `cond(current)` вернуло `true` → узел подходит.

Примеры условий:
- `IsPositiveNode` → положительное число
- `IsAlNode` → данные не число

### 5. Применение функции

```go
f(current)
```

### 6. Переход к следующему узлу

```go
current = current.Next
```

Традиционный переход в связном списке.

### 7. Пошаговый пример

#### Исходный список:

`1 → "hello" → 3 → "there" → 23 → "!" → 54 → nil`

#### Вызовы:

1. `ListForEachIf(link, PrintElem, IsPositiveNode)`
2. `ListForEachIf(link, StringToInt, IsAlNode)`

#### Этап 1 — вызов `ListForEachIf(link, PrintElem, IsPositiveNode)`

Функция `IsPositiveNode` пропускает только положительные числа.
Функция `PrintElem` печатaет данные узла.

Итерация 1

Узел: `1`
положительное число → печатаем → 1

Итерация 2

Узел: `"hello"`
не число → пропускаем

Итерация 3

Узел: `3`
положительное число → печать → 3

Итерация 4

Узел: `"there"`
пропускаем

Итерация 5

Узел: `23`
печать → 23

Итерация 6

Узел: `"!"`
пропускаем

Итерация 7

Узел: `54`
печать → 54

```go
Вывод после первого вызова:
1
3
23
54
```

#### Этап 2 — вызов `ListForEachIf(link, StringToInt, IsAlNode)`

`IsAlNode` пропускает все не числовые данные.
`StringToInt` заменяет содержимое узла на число `2`.

Итерация 1

Узел: `1`
число → пропускаем

Итерация 2

Узел: `"hello"`
строка → заменяем на 2

"hello" → 2

Итерация 3

Узел: `3`
пропускаем

Итерация 4

Узел: `"there"`
строка → заменяем на 2

"there" → 2

Итерация 5

Узел: `23`
число → пропускаем

Итерация `6`

Узел: `"!"`
строка → заменяем на 2

"!" → 2

Итерация 7

Узел: `54`
пропускаем

```go
1 → 2 → 3 → 2 → 23 → 2 → 54 → nil
```

---

## Заключение

В этом задании важно понять:
- как устроены связанные списки,
- как работает обход по ним,
- зачем нужны указатели,
- как применять функции к элементам,
- что такое «функции высшего порядка»,
- как условием выбирать, над какими узлами работать.
Эта задача отлично показывает гибкость ссылочных структур данных и силу использования функций как параметров.
