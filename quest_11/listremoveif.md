# Quest 11.11 - ListRemoveIf

## Название файла Go
`listremoveif.go`

---

## Условия задания 

| **Instruction (eng)**                                                                       | **Перевод (ru)**                                                                         |
| ------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------- |
| Write a function `ListRemoveIf` that removes all elements that are equal to the `data_ref`. | Написать функцию `ListRemoveIf`, которая удаляет все элементы списка, равные `data_ref`. |


---

Нужно написать функцию, которая удаляет все узлы из связного списка, у которых поле `Data` совпадает с переданным значением `data_ref`.

### Пример

#### Ввод:

```go
1 → Hello → 1 → There → 1 → 1 → How → 1 → are → you → 1 → nil
data_ref = 1
```

#### Вывод:

```go
Hello → There → How → are → you → nil
```

---

## Решение

```go
package piscine

func ListRemoveIf(l *List, data_ref interface{}) {
	if l.Head == nil {
		return
	}

	for l.Head != nil && l.Head.Data == data_ref {
		l.Head = l.Head.Next
	}
	if l.Head == nil {
		l.Tail = nil
		return
	}

	prev := l.Head
	current := l.Head.Next

	for current != nil {
		if current.Data == data_ref {
			prev.Next = current.Next
			if current.Next == nil {
				l.Tail = prev
			}
		} else {
			prev = current
		}
		current = current.Next
	}
}
```

---

## Ключевые понятия

| **Термин / элемент кода**            | **Объяснение**                                                                   |
| ------------------------------------ | -------------------------------------------------------------------------------- |
| **Список (List)** | Структура данных, состоящая из последовательности элементов (узлов), каждый из которых содержит данные и ссылку на следующий элемент. |
| **Узел (Node / NodeL)** | Элемент списка, который хранит данные (`Data`) и указатель на следующий узел (`Next`). |
| **Head (голова списка)** | Первый элемент списка. С него начинается обход всех узлов. |
| **Tail (хвост списка)** | Последний элемент списка. Его поле `Next` всегда `nil`. |
| **Next** | Ссылка на следующий элемент узла. |
| **Data** | Данные, хранящиеся в узле. |
| **Указатель (`*`) / Pointer** | Переменная, которая хранит **адрес** другого значения. Используется для того, чтобы функция могла изменять структуру списка напрямую, а не её копию. |
| **Итерация по списку** | Движение по узлам через `Next`.                         |
| **Интерфейс (`interface{}`)** | Универсальный тип данных в Go, который может хранить значение любого типа. |
| **data_ref**       | Значение, по которому происходит удаление.                               |
| **prev**           | Узел *до* текущего — нужен, чтобы «перепрыгнуть» удалённый узел.         |
| **current**        | Текущий проверяемый узел.                                                |
| **Структура (`struct`)** | Пользовательский тип, объединяющий несколько полей в одну сущность. В данном случае `List` и `NodeL`. |
| **Пакет (`package ...`)** | Определяет пакет, к которому принадлежит код. |
| **O(n)**               | Временная сложность — один проход по списку.            |


---

## Логика и пошаговый разбор кода

### 1. Объявление функции

```go
func ListRemoveIf(l *List, data_ref interface{}) {
```

Эта строка объявляет функцию ListRemoveIf, которая принимает:

- `l *List` — указатель на связный список, из которого нужно удалять элементы
(указатель используется, чтобы изменения были видны снаружи)
- `data_ref interface{}` — значение любого типа, которое мы ищем в `Data` каждого узла
(если `node.Data == data_ref`, узел будет удалён)


### 2. Проверка — пустой ли список

```go
if l.Head == nil {
	return
}
```

Если список пуст, делать нечего.

### 3. Удаляем элементы с начала списка (Head)

```go
for l.Head != nil && l.Head.Data == data_ref {
	l.Head = l.Head.Next
}
```

Пока первый элемент совпадает с `data_ref` — сдвигаем `Head` дальше.

#### Пример:

```go
1 → 1 → Hello → ...  
↑
Head
```

После удаления двух единиц:

```go
Hello → ...
↑
Head
```

### 4. Если всё удалили — список пуст

```go
if l.Head == nil {
	l.Tail = nil
	return
}
```

### 5. Удаляем элементы в середине и конце списка

Мы используем два указателя:
- `prev` — предыдущий узел
- `current` — текущий проверяемый узел

```go
prev := l.Head
current := l.Head.Next
```

Далее идём по списку:

```go
if current.Data == data_ref {
	prev.Next = current.Next
```

Если нашли совпадение — пропускаем узел.

### 6. Обновляем хвост (Tail), если удалён последний узел

```go
if current.Next == nil {
	l.Tail = prev
}
```

### Пошаговый пример

Исходные данные

```go
1 → Hello → 1 → There → 1 → How → you → 1 → nil
data_ref = 1
```

#### Шаг 1 — удаляем головы

Удаляем первые `1`:

```go
Hello → 1 → There → 1 → How → you → 1 → nil
↑
Head
```

#### Шаг 2 — проходим по списку

Итерация 1

`prev = Hello`, `current = 1`
Удаляем:

```go
Hello → There → 1 → How → you → 1 → nil
```

Итерация 2

`current = 1` → удаляем:

```go
Hello → There → How → you → 1 → nil
```

Итерация 3

`current = How` → оставляем.

Итерация 4

`current = you` → оставляем.

Итерация 5

`current = 1` → удаляем, обновляем Tail.

#### Итог

```go
Hello → There → How → are → you → nil
```

---

## Заключение

В этом задании важно понять:
- как работает связный список,
- как удалить элементы в начале, в середине и в конце,
- почему нужны два указателя: prev и current,
- что нельзя забывать обновлять Tail.
