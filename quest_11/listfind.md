# Quest 11.10 - ListFind

## Название файла Go
`listfind.go`

---

## Условия задания 

| **Instruction**                                                                                                                                  | **Перевод**                                                                                                                             |
| ------------------------------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------- |
| Write a function `ListFind` that returns the **address of the data** of the first node of the list `l` for which `comp(data, ref)` returns true. | Написать функцию `ListFind`, которая возвращает **адрес данных** первого узла списка `l`, для которого `comp(data, ref)` вернёт `true`. |
| For this exercise, the function `CompStr` must be used.                                                                                          | В этом упражнении обязательно нужно использовать функцию `CompStr`.                                                                     |
| If no element matches, return `nil`.                                                                                                             | Если подходящий узел не найден — вернуть `nil`.                                                                                         |


---

Нужно написать функцию, которая ищет первое совпадение в связанном списке и возвращает адрес поля Data найденного узла.

### Пример

#### Ввод

Исходный список:

```go
"hello" → "hello1" → "hello2" → "hello3" → nil
```

Вызов:

```go
found := ListFind(link, "hello2", CompStr)
```

#### Вывод

```go
0xc42000a0a0
hello2
```

---

## Решение

```go
package piscine

func CompStr(a, b interface{}) bool {
	return a == b
}

func ListFind(l *List, ref interface{}, comp func(a, b interface{}) bool) *interface{} {
	current := l.Head

	for current != nil {
		if comp(current.Data, ref) {
			return &current.Data
		}
		current = current.Next
	}
	return nil
}
```

---

## Ключевые понятия

| **Термин / элемент кода**            | **Объяснение**                                                                   |
| ------------------------------------ | -------------------------------------------------------------------------------- |
| **Список (List)** | Структура данных, состоящая из последовательности элементов (узлов), каждый из которых содержит данные и ссылку на следующий элемент. |
| **Узел (Node / NodeL)** | Элемент списка, который хранит данные (`Data`) и указатель на следующий узел (`Next`). |
| **Head (голова списка)** | Первый элемент списка. С него начинается обход всех узлов. |
| **Tail (хвост списка)** | Последний элемент списка. Его поле `Next` всегда `nil`. |
| **Next** | Ссылка на следующий элемент узла. |
| **Data** | Данные, хранящиеся в узле. |
| **Указатель (`*`) / Pointer** | Переменная, которая хранит **адрес** другого значения. Используется для того, чтобы функция могла изменять структуру списка напрямую, а не её копию. |
| **Type assertion**     | Проверка и преобразование типа (`.(int)`, `.(string)`). |
| **comp func(a, b interface{}) bool**        | Функция сравнения, определяет равны ли два значения.    |
| **Итерация по списку** | Движение по узлам через `Next`.                         |
| **Интерфейс (`interface{}`)** | Универсальный тип данных в Go, который может хранить значение любого типа. |
| **Указатель на interface (`*interface{}`)** | Функция возвращает адрес значения, а не копию.          |
| **Структура (`struct`)** | Пользовательский тип, объединяющий несколько полей в одну сущность. В данном случае `List` и `NodeL`. |
| **Пакет (`package ...`)** | Определяет пакет, к которому принадлежит код. |

---

## Логика и пошаговый разбор кода

### 1. Объявление функции

```go
func ListFind(l *List, ref interface{}, comp func(a, b interface{}) bool) *interface{} {
```
Эта строка объявляет функцию **ListFind**, которая принимает:

Функция принимает:
- `l` — список
- `ref` — значение, которое ищем
- `comp` — функция сравнения (например `CompStr`)
Возвращает:
- `*interface{}` — адрес данных найденного узла
- `nil` — если ничего не найдено


### 2. Начинаем обход списка

```go
current := l.Head
```

Берём первый узел (голову списка).

### 3. Цикл обхода

```go
for current != nil {
```

Простой проход по списку от начала до конца.

### 4. Сравнение данных узла с искомым значением

```go
if comp(current.Data, ref) {
	return &current.Data
}
```

- `comp` — функция сравнения
- `comp(a, b)` возвращает true, если значения равны
Если совпадение найдено → возвращаем адрес `Data`, а не копию.

### 5. Переход к следующему узлу

```go
current = current.Next
```

### 6. Если в списке ничего нет

```go
return nil
```

### Пошаговый пример

Исходный список:

```go
"hello" → "hello1" → "hello2" → "hello3" → nil
```

Вызов:

```go
ListFind(link, "hello2", CompStr)
```

Итерация 1

Узел: `"hello"`
Сравниваем: `"hello" == "hello2"` → нет
Переходим дальше

Итерация 2

Узел: `"hello1"`
Сравниваем: `"hello1" == "hello2"` → нет
Двигаемся дальше

Итерация 3

Узел: `"hello2"`
Сравниваем: `"hello2" == "hello2"` → совпало!

Возвращаем адрес `Data`:

```go
0xc42000a0a0
```

А затем:

```go
*found == "hello2"
```

#### Итоговый вывод программы

```go
0xc42000a0a0
hello2
```

---

## Заключение

В этом задании важно понять:
- как искать элемент в связанном списке
- как пользоваться функциями сравнения (`comp`)
- как возвращать адрес данных, а не значение
- зачем нужен интерфейс `interface{}`
- как устроен проход по списку
Хорошее упражнение на указатели, логику обхода и работу с интерфейсами.