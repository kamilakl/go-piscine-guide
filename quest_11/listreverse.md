# Quest 11.7 - List Reverse

## Название файла
`listreverse.go`

---

## Условия задания

| **Instruction** | **Перевод** |
|-----------------|--------------|
| *Write a function `ListReverse` that reverses the order of the elements of a given linked list `l`.* | *Напишите функцию `ListReverse`, которая разворачивает порядок элементов односвязного списка `l`.* |

После выполнения `ListReverse(l)` порядок узлов должен стать противоположным:

- **Было:** `1 → 2 → 3 → 4 → <nil>`
- **Стало:** `4 → 3 → 2 → 1 → <nil>`

---

## Решение

```go
package piscine

func ListReverse(l *List) {
	if l.Head == nil {
		return
	}

	var prev *NodeL = nil
	current := l.Head
	l.Tail = l.Head

	for current != nil {
		next := current.Next
		current.Next = prev
		prev = current
		current = next
	}

	l.Head = prev
}
```

---

## Ключевые понятия

| **Термин / элемент кода**            | **Объяснение**                                                                   |
| ------------------------------------ | -------------------------------------------------------------------------------- |
| **Список (List)** | Структура данных, состоящая из последовательности элементов (узлов), каждый из которых содержит данные и ссылку на следующий элемент. |
| **Узел (Node / NodeL)** | Элемент списка, который хранит данные (`Data`) и указатель на следующий узел (`Next`). |
| **Head (голова списка)** | Первый элемент списка. С него начинается обход всех узлов. |
| **Tail (хвост списка)** | Последний элемент списка. Его поле `Next` всегда `nil`. |
| **Next** | Ссылка на следующий элемент узла. |
| **Data** | Данные, хранящиеся в узле. |
| **Указатель (`*`) / Pointer** | Переменная, которая хранит **адрес** другого значения. Используется для того, чтобы функция могла изменять структуру списка напрямую, а не её копию. |
| **nil** | Нулевое значение указателя в Go. Означает, что ссылка никуда не указывает. |
| **Интерфейс (`interface{}`)** | Универсальный тип данных в Go, который может хранить значение любого типа. |
| **Структура (`struct`)** | Пользовательский тип, объединяющий несколько полей в одну сущность. В данном случае `List` и `NodeL`. |
| **Пакет (`package ...`)** | Определяет пакет, к которому принадлежит код. |
| **prev / current / next**            | Техника тройных указателей для разворота списка.                                 |
| **O(n)**                             | Временная сложность — нужно пройти все элементы один раз.                        |
| **Операция O(1)** | Означает, что операция выполняется за постоянное время, независимо от длины списка. |


---

## Логика и пошаговый разбор кода

### 1. Объявление функции

```go
func ListReverse(l *List) {
```
Эта строка объявляет функцию **ListReverse**, которая принимает:

Функция принимает:
- `l *List` — указатель на список, который нужно развернуть.
Указатель важен, потому что мы меняем сам список, а не копию.

### 2. Обработка пустого списка

```go
if l.Head == nil {
    return
}
```

Если голова пустая → список пуст → делать нечего.

### 3. Подготовка переменных

```go
var prev *NodeL = nil
current := l.Head
l.Tail = l.Head
```

- `prev` — ранее обработанный узел (в начале его нет).
- `current` — текущий узел, с которого начинаем.
- `l.Tail = l.Head` — текущая голова станет новым хвостом, это важно.

### 4. Основной цикл разворота

```go
for current != nil {
    next := current.Next
    current.Next = prev
    prev = current
    current = next
}
```

#### Разбор по шагам:

##### Шаг 1: Сохраняем следующий элемент

```go
next := current.Next
```

Иначе потеряем ссылку дальше по списку.

##### Шаг 2: Разворачиваем указатель

```go
current.Next = prev
```

Теперь текущий узел “смотрит назад”.

##### Шаг 3: Сдвигаем prev

```go
prev = current
```

Текущий узел становится предыдущим.

###### Шаг 4: Переходим к следующему узлу

```go
current = next
```

Так шаг за шагом переворачиваются все связи.

### 5. Финальное обновление головы

```go
l.Head = prev
```

Когда цикл закончился — `prev` указывает на новую голову списка.

### Визуальный пример

Возьмём исходный список:

```go
Head -> 1 -> 2 -> 3 -> 4 -> nil
Tail -> 4
```
Перед входом в цикл в коде у нас:

```go
var prev *NodeL = nil
current := l.Head    // current -> 1
l.Tail = l.Head      // Tail -> 1 (будет новым хвостом)
```

Мы будем на каждой итерации сохранять `next := current.Next`, затем направлять `current.Next = prev`, смещать `prev = current` и переходить `current = next`.
Ниже — таблица, показывающая состояние переменных и связей на каждой итерации.

| Итерация    | prev (значение) | current (значение) | next (значение) | Действие (current.Next = prev) | Состояние списка (строки связей)                |
| ----------- | --------------: | -----------------: | --------------: | ------------------------------ | ----------------------------------------------- |
| Начало      |           `nil` |                `1` |               — | —                              | `1 -> 2 -> 3 -> 4 -> nil`                       |
| 1           |           `nil` |                `1` |             `2` | `1.Next = nil`                 | `1 -> nil`  and remaining `2->3->4` (separated) |
| 1 (обновл.) |             `1` |                `2` |             `3` | (prev теперь 1)                | links: `1 -> nil`, `2 -> 3 -> 4 -> nil`         |
| 2           |             `1` |                `2` |             `3` | `2.Next = 1`                   | `2 -> 1 -> nil`, remaining `3->4`               |
| 2 (обновл.) |             `2` |                `3` |             `4` | (prev теперь 2)                | `2 -> 1 -> nil`, `3 -> 4 -> nil`                |
| 3           |             `2` |                `3` |             `4` | `3.Next = 2`                   | `3 -> 2 -> 1 -> nil`, remaining `4`             |
| 3 (обновл.) |             `3` |                `4` |           `nil` | (prev теперь 3)                | `3 -> 2 -> 1 -> nil`, `4 -> nil`                |
| 4           |             `3` |                `4` |           `nil` | `4.Next = 3`                   | `4 -> 3 -> 2 -> 1 -> nil`                       |
| Конец       |             `4` |              `nil` |               — | цикл завершён                  | итог: `Head` := `prev` -> `4`                   |

Пояснения к таблице:

- **Итерация 1**:
    - Сохраняем `next = 2`.
    - Делаем `1.Next = prev` (prev был `nil`), теперь `1` указывает на `nil`.
    - Переносим `prev = 1`, `current = 2`.
- **Итерация 2**:
    - `next = 3`.
    - `2.Next = prev` (т.е. `2.Next = 1`), теперь `2 -> 1 -> nil`.
    - `prev = 2`, `current = 3`.
- **Итерация 3**:
    - `next = 4`.
    - `3.Next = prev` → `3 -> 2 -> 1 -> nil`.
    - `prev = 3`, `current = 4`.
- **Итерация 4**:
    - `next = nil`.
    - `4.Next = prev` → `4 -> 3 -> 2 -> 1 -> nil`.
    - `prev = 4`, `current = nil` — цикл останавливается.

После цикла делаем:

```go
l.Head = prev   // prev -> 4 — это новая голова
// l.Tail уже был установлен раньше: l.Tail = original Head (1)
```

Итоговое состояние:

```go
Head -> 4 -> 3 -> 2 -> 1 -> nil
Tail -> 1
```

**Важные замечания**

- Мы заранее установили `l.Tail = l.Head` перед циклом, потому что исходная голова становится новым хвостом.
- Алгоритм меняет связи на месте (без выделения новых узлов), поэтому использует **O(1)** дополнительной памяти.
- Временная сложность **O(n)**: каждый узел обрабатывается ровно один раз.
- Этот приём — стандартная техника: использовать три указателя `prev`, `current`, `next`.

---

## Заключение

- `ListReverse` — классическая задача на работу со связным списком.
- Она тренирует работу с указателями и алгоритм разворота.
- Используются три указателя (`prev`, `current`, `next`) — надёжный способ перевернуть любой односвязный список.
- Функция выполняется за **O(n)** и не использует дополнительную память.
- После разворота важно обновить и `Head`, и `Tail`, иначе список будет работать некорректно.
