# Quest 11.2. List Size

## Название файла Go
`listsize.go`

---

## Условия задания 

| **Instruction** | **Перевод** |
|---------------------------|--------------|
| *Write a function `ListSize` that returns the number of elements in a linked list `l`.* | *Напишите функцию `ListSize`, которая возвращает количество элементов в односвязном списке `l`.* |

---

Функция должна пройти по всем узлам списка, начиная с `Head`, подсчитать их количество и вернуть итоговое число.

### Пример

- **Ввод:** список содержит узлы `"man"`, `"you"`, `"2"`, `"Hello"`
- **Вывод:** `4`

---

## Решение

```go
package piscine

func ListSize(l *List) int {
	count := 0
	current := l.Head

	for current != nil {
		count++
		current = current.Next
	}
	return count
}
```

---

## Ключевые понятия

| **Термин / элемент кода**            | **Объяснение и назначение**                                                      |
| ------------------------------------ | -------------------------------------------------------------------------------- |
| **Список (List)** | Структура данных, состоящая из последовательности элементов (узлов), каждый из которых содержит данные и ссылку на следующий элемент. |
| **Узел (Node / NodeL)** | Элемент списка, который хранит данные (`Data`) и указатель на следующий узел (`Next`). |
| **Head (голова списка)** | Первый элемент списка. С него начинается обход всех узлов. |
| **Tail (хвост списка)** | Последний элемент списка. Его поле `Next` всегда `nil`. |
| **Next** | Ссылка на следующий элемент узла. |
| **Data** | Данные, хранящиеся в узле. |
| **Указатель (`*`) / Pointer** | Переменная, которая хранит **адрес** другого значения. Используется для того, чтобы функция могла изменять структуру списка напрямую, а не её копию. |
| **nil** | Нулевое значение указателя в Go. Означает, что ссылка никуда не указывает. |
| **Интерфейс (`interface{}`)** | Универсальный тип данных в Go, который может хранить значение любого типа. |
| **Структура (`struct`)** | Пользовательский тип, объединяющий несколько полей в одну сущность. В данном случае `List` и `NodeL`. |
| **Итерация списка**                  | Последовательный переход от одного узла к другому через поле `Next`.             |
| **Линейная сложность (O(n))**        | Обход всех узлов требует времени, пропорционального размеру списка.              |

---

## Логика и пошаговый разбор кода

### 1. Объявление функции

```go
func ListSize(l *List) int {
```
Эта строка объявляет функцию **ListSize**, которая принимает:

Функция принимает:
- `l` — указатель на список `List`.
- Возвращает `int` — количество элементов.
Использование указателя (`*List`) важно, потому что ссылка даёт доступ к настоящему списку, а не его копии.


### 2. Инициализация счётчика и указателя

```go
count := 0
current := l.Head
```

- `count` — будет считать количество узлов. Начинается с нуля.
- `current` — указатель, который будет перемещаться по списку, начиная с головы.

### 3. Обход списка

```go
for current != nil {
	count++
	current = current.Next
}
```

Цикл работает так:
- Пока `current` существует (не `nil`), мы:
    - Увеличиваем счётчик узлов.
    - Переходим к следующему узлу (`current = current.Next`).
Цикл закончится, когда мы дойдём до последнего элемента — его поле `Next` равно `nil`.

### 4. Возврат результата

`return count`

Функция возвращает количество узлов, которые она прошла.


### 5. Пошаговый разбор примера

`Head → [man] → [you] → [2] → [Hello] → nil`

Ход работы функции:
| Шаг | current указывает на | count            |
| --- | -------------------- | ---------------- |
| 1   | `"man"`              | 1                |
| 2   | `"you"`              | 2                |
| 3   | `"2"`                | 3                |
| 4   | `"Hello"`            | 4                |
| 5   | nil                  | цикл завершается |

Возвращается `4`.

---

### Заключение

- ListSize проходит по каждому узлу списка и считает их количество.
- Это простейшая операция работы с односвязным списком.
- Сложность — O(n), потому что требуется пройти каждый элемент.
- Функция показывает, как работает базовая итерация по структуре linked list.
- Понимание этой логики важно для следующих задач: удаления, поиска, реверса списка, работы с очередями.
