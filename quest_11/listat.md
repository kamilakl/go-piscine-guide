# Quest 11.6 - listat

## Название файла Go
`listat.go`

---

## Условия задания 

| **Instruction** | **Перевод** |
|---------------------------|--------------|
| *Write a function `ListAt` that takes a pointer to the head of the list `l` and an int `pos` as parameters.* | *Напишите функцию `ListAt`, которая принимает указатель на голову списка `l` и число `pos`.* |
| *This function should return the pointer to the NodeL in the position `pos` of the linked list.*             | *Функция должна вернуть указатель на узел `NodeL`, находящийся на позиции `pos`.*            |
| *In case of error the function should return nil.*                                                           | *В случае ошибки функция должна вернуть `nil`.*                                              |

---

Функция должна пройти по односвязному списку и вернуть узел, расположенный на позиции `pos`, начиная с нуля (`0` — первый элемент).

Если:
- позиция выходит за пределы списка,- 
- или список пуст,
- или позиция отрицательная —
→ возвращаем `nil`.

### Пример

Пусть есть список:

```go
hello -> how are -> you -> 1 -> <nil>
```

Тогда:

| Вызов                  | Результат          |
| ---------------------- | ------------------ |
| `ListAt(link.Head, 0)` | узел с `"hello"`   |
| `ListAt(link.Head, 1)` | узел с `"how are"` |
| `ListAt(link.Head, 3)` | узел с `1`         |
| `ListAt(link.Head, 7)` | `nil`              |

---

## Решение

```go
package piscine

func ListAt(l *NodeL, pos int) *NodeL {
	if l == nil || pos < 0 {
		return nil
	}

	current := l
	index := 0

	for current != nil {
		if index == pos {
			return current
		}
		current = current.Next
		index++
	}

	return nil
}
```

---

## Ключевые понятия

| **Термин / элемент кода**            | **Объяснение и назначение**                                                    |
| ------------------------------------ | ------------------------------------------------------------------------------ |
| **Список (List)** | Структура данных, состоящая из последовательности элементов (узлов), каждый из которых содержит данные и ссылку на следующий элемент. |
| **Узел (Node / NodeL)** | Элемент списка, который хранит данные (`Data`) и указатель на следующий узел (`Next`). |
| **Head (голова списка)** | Первый элемент списка. С него начинается обход всех узлов. |
| **Tail (хвост списка)** | Последний элемент списка. Его поле `Next` всегда `nil`. |
| **Next** | Ссылка на следующий элемент узла. |
| **Data** | Данные, хранящиеся в узле. |
| **Указатель (`*`) / Pointer** | Переменная, которая хранит **адрес** другого значения. Используется для того, чтобы функция могла изменять структуру списка напрямую, а не её копию. |
| **nil** | Нулевое значение указателя в Go. Означает, что ссылка никуда не указывает. |
| **Интерфейс (`interface{}`)** | Универсальный тип данных в Go, который может хранить значение любого типа. |
| **Структура (`struct`)** | Пользовательский тип, объединяющий несколько полей в одну сущность. В данном случае `List` и `NodeL`. |
| **Пакет (`package ...`)** | Определяет пакет, к которому принадлежит код. |
| **pos (позиция)** | Индекс элемента, начиная с 0. |
| **Итерация списка** | Проход по узлам через `Next`, т.к. случайного доступа (как в массиве) нет. |
| **Линейная сложность (O(n))**        | Обход всех узлов требует времени, пропорционального размеру списка.              |

---

## Логика и пошаговый разбор кода

### 1. Объявление функции

```go
func ListAt(l *NodeL, pos int) *NodeL{
```

Эта строка объявляет функцию **ListAt**, которая принимает два параметра:
`l *NodeL` — указатель на голову списка (первый узел). Важно: функция получает именно указатель на узел, а не всю структуру `List`.
`pos int` — позиция (индекс) требуемого узла, где отсчёт начинается с `0`.
Функция возвращает `*NodeL` — указатель на узел на позиции `pos`, либо `nil`, если позиция некорректна или список слишком короткий.

### 2. Проверка входных данных

```go
if l == nil || pos < 0 {
    return nil
}
```

- Если `l == nil`, значит список пуст — возвращаем `nil`.
- Если `pos < 0`, позиция некорректна — тоже возвращаем `nil`.
Это базовая валидация, предотвращающая дальнейший обход и возможные паники.

### 3. Инициализация указателя и счётчика

```go
current := l
index := 0
```

### 4. Обход списка и сравнение индекса

```go
for current != nil {
    if index == pos {
        return current
    }
    current = current.Next
    index++
}
```

- Цикл идёт по всем узлам, пока `current != nil`.
- На каждой итерации сравниваем `index` с искомым `pos`.
    - Если равны — найден нужный узел, возвращаем `current`.
    - Иначе — перемещаемся к следующему узлу (`current = current.Next`) и увеличиваем `index`.
- Такой последовательный перебор — стандартная техника для доступа по индексу в **linked list**.

### 5. Возврат `nil`, если позиция вне диапазона

```go
return nil
```

Если цикл закончился (дошли до `nil`) и нужная позиция не найдена, значит `pos` больше или равна длине списка — возвращаем `nil`.

---

## Заключение

- Функция принимает указатель на голову списка и индекс; возвращает указатель на узел по этому индексу или `nil`.
- Сначала выполняется валидация входных данных, затем последовательный обход через `Next`.
- Временная сложность — **O(n)** в худшем случае (нужно пройти до конца списка).
- Возвращаемый указатель позволяет работать с найденным узлом (читать/изменять `Data`, менять `Next` и т.д.).
