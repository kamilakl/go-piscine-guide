# Quest 11.14 - SortListInsert

## Название файла Go
`sortlistinsert.go`

---

## Условия задания 

| **Instruction (eng)**                                                                 | **Перевод (ru)**                                                                    |
| ------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------- |
| Write a function `SortListInsert` that inserts a new node into a sorted linked list. | Написать функцию `SortListInsert`, которая вставляет новый узел в отсортированный список. |

---

Функция принимает указатель на голову отсортированного односвязного списка целых чисел и значение.  
Нужно вставить новый элемент так, чтобы список остался отсортированным по возрастанию.  
Функция возвращает голову списка.

### Пример

Исходный список:

```go
1 -> 4 -> 9 -> nil
```


Вставляем `2` и `-2`:

```go
-2 -> 1 -> 2 -> 4 -> 9 -> nil
```


---

## Решение

**Вы уже определили структуру `NodeI` в упражнении `listsort`.**

```go
package piscine

func SortListInsert(l *NodeI, data_ref int) *NodeI {
    newNode := &NodeI{Data: data_ref}

    if l == nil || data_ref <= l.Data {
        newNode.Next = l
        return newNode
    }

    current := l
    for current.Next != nil && current.Next.Data < data_ref {
        current = current.Next
    }

    newNode.Next = current.Next
    current.Next = newNode

    return
}
```
---

## Ключевые понятия

| **Термин / элемент кода**            | **Объяснение**                                                                   |
| ------------------------------------ | -------------------------------------------------------------------------------- |
| **Список (List)** | Структура данных, состоящая из последовательности элементов (узлов), каждый из которых содержит данные и ссылку на следующий элемент. |
| **Узел (Node / NodeL)** | Элемент списка, который хранит данные (`Data`) и указатель на следующий узел (`Next`). |
| **Head (голова списка)** | Первый элемент списка. С него начинается обход всех узлов. |
| **Tail (хвост списка)** | Последний элемент списка. Его поле `Next` всегда `nil`. |
| **Next** | Ссылка на следующий элемент узла. |
| **Data** | Данные, хранящиеся в узле. |
| **Указатель (`*`) / Pointer** | Переменная, которая хранит **адрес** другого значения. Используется для того, чтобы функция могла изменять структуру списка напрямую, а не её копию. |
| **Итерация по списку** | Движение по узлам через `Next`.                         |
| **Интерфейс (`interface{}`)** | Универсальный тип данных в Go, который может хранить значение любого типа. |
| **Структура (`struct`)** | Пользовательский тип, объединяющий несколько полей в одну сущность. В данном случае `List` и `NodeL`. |
| **Пакет (`package ...`)** | Определяет пакет, к которому принадлежит код. |
| **Insertion Sort** | Алгоритм сортировки, который вставляет каждый элемент на своё место в уже отсортированной части списка. |
| **O(n)**       | Временная сложность алгоритма сортировки пузырьком в худшем случае.                                        |
| **nil**         | Конец списка.                                                                                              |

---

## Логика и пошаговый разбор кода

### 1. Объявление функции

```go
func SortListInsert(l *NodeI, data_ref int) *NodeI {
```
Эта строка объявляет функцию **SortListInsert**, которая принимает:
`l *NodeI` — указатель на голову отсортированного списка
`data_ref int` — значение нового узла


### 2. Создание нового узла

```go
newNode := &NodeI{Data: data_ref}
```

Создаём новый узел с полем `Data`, равным `data_ref`.

### 3. Вставка в начало списка

```go
if l == nil || data_ref <= l.Data {
    newNode.Next = l
    return newNode
}
```

- Если список пуст (`l == nil`) или новое значение меньше или равно головы (`data_ref <= l.Data`) - новый узел становится головой списка.
- `newNode.Next = l` соединяет новый узел с остальной частью списка.

### 4. Поиск позиции для вставки

```go
current := l
for current.Next != nil && current.Next.Data < data_ref {
    current = current.Next
}
```

- `current` указывает на текущий узел при проходе по списку.
- Проходим по списку, пока следующий узел (`current.Next`) меньше нового значения.
- В итоге `current` указывает на узел, после которого нужно вставить новый элемент.

### 5. Вставка нового узла

```go
newNode.Next = current.Next
current.Next = newNode
```

- `newNode.Next = current.Next` — новый узел "подключается" к следующему узлу списка.
- `current.Next = newNode` — предыдущий узел теперь указывает на новый узел.

### 6. Возврат головы списка

```go
return l
```

- Возвращаем голову списка, которая может не измениться, если вставка была не в начало.
- Список остаётся отсортированным.

### Пошаговый пример

Исходный список:

```go
1 -> 4 -> 9 -> nil
```

Вставляем `2`:

| Шаг | Действие                    | Состояние списка        |
| --- | --------------------------- | ----------------------- |
| 1   | `2 > 1` → идём дальше       | 1 -> 4 -> 9 -> nil      |
| 2   | `2 < 4` → вставляем перед 4 | 1 -> 2 -> 4 -> 9 -> nil |

---

## Заключение

- `SortListInsert` позволяет вставлять элементы в уже отсортированный список.
- Список остаётся отсортированным без повторной сортировки всех элементов.
- Использование указателей позволяет изменять структуру списка напрямую.
- Сложность алгоритма **O(n)**.