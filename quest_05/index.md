# Quest 5.6 Index

## Название файла Go
`index.go`

---

## Условия задания 

| **Instruction** | **Перевод** |
|---------------------------|--------------|
| Write a function that behaves like the Index function. | Напиши функцию, которая ведёт себя как функция `Index`. |

---

Нужно написать функцию, которая **находит подстроку** в строке и возвращает индекс (позицию) её первого вхождения.  
Если подстрока не найдена — функция должна вернуть `-1`.  
Если подстрока пуста (`""`), нужно вернуть `0`.

---

### Пример

- **Ввод:**
  ```go
  fmt.Println(piscine.Index("Hello!", "l"))
  fmt.Println(piscine.Index("Salut!", "alu"))
  fmt.Println(piscine.Index("Ola!", "hOl"))
  ```
- **Вывод:**
  ```
  2
  1
  -1
  ```

Дополнительно:
- `piscine.Index("Ola!", "")` → `0`
- `piscine.Index("Hello", "world")` → `-1`

---

## Решение

```go
package piscine

func Index(s string, toFind string) int {
	if len(toFind) == 0 {
		return 0
	}
	for i := 0; i < len(s)-len(toFind); i++ {
		if s[i:i+len(toFind)] == toFind {
			return i
		}
	}
	return -1
}
```

---

## Ключевые понятия

| **Инструмент / элемент кода** | **Объяснение и назначение** |
|-------------------------------|------------------------------|
| **Пакет (`package piscine`)** | Объявляет пакет `piscine`, чтобы программа могла найти и использовать функцию. |
| **Цикл (`for i := 0; i < len(s)-len(toFind); i++`)** | Перебирает все возможные позиции в строке `s`, где может начинаться подстрока `toFind`. |
| **Выражение `s[i:i+len(toFind)]`** | Извлекает срез строки длиной, равной `len(toFind)`, начиная с позиции `i`. Это "окно" для проверки подстроки. |
| **Сравнение (`== toFind`)** | Проверяет, совпадает ли извлечённый участок строки `s` с подстрокой `toFind`. |
| **`return i`** | Если найдено совпадение — возвращает индекс, с которого начинается подстрока. |
| **`return -1`** | Если подстрока не найдена, возвращает `-1`. |
| **`len()`** | Встроенная функция, возвращающая длину строки в байтах. |
| **UTF-8** | Кодировка, в которой каждая буква может занимать 1–4 байта. Go сравнивает строки посимвольно по байтам, а не по рунам. |
| **Побайтовое сравнение** | Важно помнить, что `s[i]` в Go — это **байт**, а не символ (`rune`). Поэтому функция корректно работает с латинскими символами, но может давать неверные индексы для Unicode-символов. |

---

## Логика и пошаговый разбор кода

### 1. Проверка на пустую подстроку

```go
if len(toFind) == 0 {
	return 0
}
```
Если строка `toFind` пустая, функция сразу возвращает `0`, так как пустая строка считается найденной в начале любой строки.

---

### 2. Перебор возможных позиций в строке

```go
for i := 0; i < len(s)-len(toFind); i++ {
```
Цикл проходит по всем возможным индексам, где может начинаться подстрока.  
Если длина `s` равна 6, а длина `toFind` равна 3, то цикл выполнится для `i = 0, 1, 2, 3`.

---

### 3. Проверка совпадения подстроки

```go
if s[i:i+len(toFind)] == toFind {
	return i
}
```
Здесь создаётся срез `s[i:i+len(toFind)]` и сравнивается с `toFind`.  
Если они совпадают — возвращаем индекс `i`, то есть позицию, где начинается совпадение.

---

### 4. Подстрока не найдена

```go
return -1
```
Если весь цикл прошёл и совпадений не найдено, возвращаем `-1`.

---

## Важно знать

> В Go строки состоят из **байт**, а не из символов.  
> Поэтому при обращении через `s[i]` или срез `s[i:j]` вы работаете с байтами UTF-8.  
> Для работы с символами Unicode нужно использовать `[]rune`, но в этой задаче это не требуется, так как `Index` работает именно побайтово (аналогично стандартной функции `strings.Index`).

Пример:

```go
s := "Привет"
fmt.Println(len(s))     // 12 потому что каждая буква занимает 2 байта
fmt.Println([]rune(s))  // [1055 1088 1080 1074 1077 1090] — каждая руна это символ
```

---

## Глоссарий

| **Термин** | **Пояснение** |
|-------------|----------------|
| **подстрока (substring)** | Непрерывная часть строки, например: в `"Hello"` подстрока `"ell"`. |
| **байт (byte)** | Минимальная единица хранения данных (8 бит). В Go `byte` = `uint8`. |
| **rune** | Тип данных (`int32`), представляющий один символ Unicode. |
| **UTF-8** | Кодировка, где символ может занимать от 1 до 4 байт. |
| **len()** | Функция, возвращающая длину строки в байтах. |
| **return** | Завершает выполнение функции и возвращает значение. |
| **for loop** | Цикл, который выполняет действия заданное количество раз. |
| **slice (срез)** | Фрагмент строки или массива. В примере `s[i:i+len(toFind)]` — это срез строки. |

---

## Заключение

Функция **Index** ищет подстроку в строке и возвращает позицию её первого вхождения.  
Если подстрока не найдена — возвращает `-1`.  
Если подстрока пустая — возвращает `0`.

### Алгоритм:
1. Проверяем, пуста ли строка `toFind`.  
2. Перебираем все возможные индексы начала подстроки.  
3. Сравниваем фрагмент строки с `toFind`.  
4. Если совпадение найдено — возвращаем индекс.  
5. Если нет — возвращаем `-1`.
