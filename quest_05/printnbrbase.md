# Quest 5. Print Number in Base

## Название файла Go
`printnbrbase.go`

---

## Условия задания

| **Instruction** | **Перевод** |
|-----------------|-------------|
| Write a function that prints an `int` in a `string` base passed as parameters. If the base is not valid, the function prints NV. | Напишите функцию, которая печатает число в системе счисления, переданной строкой. Если база недействительна — вывести `NV`. |

---

### Требования к валидной базе
База считается корректной, если:
- содержит минимум 2 символа;
- все символы уникальны;
- нет знаков `+` или `-`.

Функция должна работать с отрицательными числами.

---

### Пример

Вход:
```go
PrintNbrBase(255, "0123456789")
PrintNbrBase(255, "01")
PrintNbrBase(-255, "01")
PrintNbrBase(123, "aab")
```

Вывод:
```
255
11111111
-11111111
NV
```

---

## Решение

```go
package piscine

import "github.com/01-edu/z01"

func isValidBase(base string) bool {
	if len(base) < 2 {
		return false
	}
	for i := 0; i < len(base); i++ {
		if base[i] == '+' || base[i] == '-' {
			return false
		}
		for j := i + 1; j < len(base); j++ {
			if base[i] == base[j] {
				return false
			}
		}
	}
	return true
}

func PrintNbrBase(nbr int, base string) {
	if !isValidBase(base) {
		z01.PrintRune('N')
		z01.PrintRune('V')
		return
	}

	baseLen := len(base)

	if nbr == -9223372036854775808 {
		z01.PrintRune('-')
		PrintNbrBase(-(nbr/baseLen), base)
		z01.PrintRune(rune(base[-(nbr%baseLen)]))
		return
	}

	if nbr < 0 {
		z01.PrintRune('-')
		nbr = -nbr
	}

	if nbr >= baseLen {
		PrintNbrBase(nbr/baseLen, base)
	}
	z01.PrintRune(rune(base[nbr%baseLen]))
}
```

---

## Ключевые понятия (сжатые, только важное)

| Инструмент / элемент | Объяснение |
|----------------------|-----------|
| **Проверка валидности базы** | Система счисления должна быть корректной: уникальные символы, >=2 символов, нет `+`/`-`. |
| **Рекурсия** | В этом задании, позволяет вывести цифры в правильном порядке (слева направо). |
| **MIN_INT специальный случай** | Значение `-9223372036854775808` нельзя инвертировать (`-x` вызывает overflow), поэтому оно обрабатывается отдельно. |

---

## Логика и пошаговый разбор кода

### 1. Проверка базы — фундамент безопасности

```go
if !isValidBase(base) {
    Print "NV"
    return
}
```

Мы убеждаемся, что:
- у базы есть хотя бы 2 символа,  
- нет `+` и `-`,  
- все символы уникальны.

Если база некорректная — дальнейшие вычисления **не имеют смысла**, и функция сразу возвращает `"NV"`.

---

### 2. Спец-случай: минимальное значение `int`

```go
if nbr == -9223372036854775808 {
```

Это **минимальное число int64**. Почему особый случай?
`-MIN_INT` выходит за пределы диапазона → **overflow**.  Поэтому мы разбираем его вручную:
```go
z01.PrintRune('-')
PrintNbrBase(-(nbr/baseLen), base)
PrintRune(base[-(nbr % baseLen)])
```

То есть:
- печатаем знак,
- выводим старшие цифры через рекурсию,
- потом выводим последнюю цифру.

---

### 3. Обработка обычного отрицательного числа

```go
if nbr < 0 {
	z01.PrintRune('-')
	nbr = -nbr
}
```

Теперь можно безопасно инвертировать (кроме MIN_INT, обработанного выше).

---

### 4. Рекурсия — ключ к правильному порядку цифр

Обычный алгоритм перевода в другую базу:

- остатки (`nbr % baseLen`) дают **младшие цифры**,
- деление (`nbr / baseLen`) идёт к старшим.

Если выводить сразу то получится перевёрнутый результат.  
Чтобы сделать правильно:

```go
if nbr >= baseLen {
    PrintNbrBase(nbr/baseLen, base)
}
z01.PrintRune(rune(base[nbr%baseLen]))
```

Рекурсия идёт вглубь до самой старшей цифры,  
а вывод происходит при возвращении вверх по стеку.

---

### 5. Вывод последней цифры

```go
z01.PrintRune(rune(base[nbr%baseLen]))
```

Это символ в базе, соответствующий остатку — младшей цифре.

---

## Как построить логику (коротко и важно)

1. **Проверить валидность базы**.  
   Если база неправильная то `NV`.

2. **Прописать обработку отрицательных чисел**, включая MIN_INT.

3. **Перевести число в другую базу через деление и остаток**:
   - `digit = nbr % baseLen`
   - `nbr = nbr / baseLen`

4. **Использовать рекурсию**, чтобы цифры печатались в правильном порядке.

5. **Вывести цифру**, соответствующую остатку.

---

## Заключение

Эта задача учит:

- понимать структуру систем счисления;
- корректно валидировать входные данные;
- работать с рекурсией для разворота порядка цифр;
- избегать overflow на MIN_INT;
- выводить символы посимвольно.

После этого задания становится понятно, **как устроены преобразования чисел в любую систему счисления**, и почему рекурсия здесь — самый естественный инструмент.

